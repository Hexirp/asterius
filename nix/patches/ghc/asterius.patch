From fa3076b53feda607e9b6049eafad5d5eab151ed4 Mon Sep 17 00:00:00 2001
From: Michael Sloan <mgsloan@gmail.com>
Date: Thu, 26 Jul 2018 17:17:41 -0400
Subject: [PATCH 01/12] Add a script for running a ghci that can load and run
 ghc

Add scripts and .ghci files for loading GHC into GHCi

Major credit to Csongor Kiss who wrote nearly all of settings.ghci

Some small modifications to GHC are needed to make this work, and this
diff depends on [D4986](https://phabricator.haskell.org/D4986) being
merged.

Test Plan:
Manual for now. I have some thoughts on how to run the entire testsuite
against
GHC-in-GHCi.

Reviewers: alpmestan, mpickering, goldfire, bgamari, erikd

Reviewed By: alpmestan

Subscribers: rwbarton, thomie, carter

Differential Revision: https://phabricator.haskell.org/D4904
---
 .ghcid                           |  7 ++++++
 utils/ghc-in-ghci/inner.ghci     |  1 +
 utils/ghc-in-ghci/load-main.ghci |  1 +
 utils/ghc-in-ghci/run.sh         | 36 ++++++++++++++++++++++++++++
 utils/ghc-in-ghci/settings.ghci  | 41 ++++++++++++++++++++++++++++++++
 5 files changed, 86 insertions(+)
 create mode 100644 .ghcid
 create mode 100644 utils/ghc-in-ghci/inner.ghci
 create mode 100644 utils/ghc-in-ghci/load-main.ghci
 create mode 100755 utils/ghc-in-ghci/run.sh
 create mode 100644 utils/ghc-in-ghci/settings.ghci

diff --git a/.ghcid b/.ghcid
new file mode 100644
index 0000000000..f751a6fc83
--- /dev/null
+++ b/.ghcid
@@ -0,0 +1,7 @@
+--command utils/ghc-in-ghci/run.sh
+--reload compiler
+--reload ghc
+--reload includes
+--restart utils/ghc-in-ghci/run.sh
+--restart utils/ghc-in-ghci/load-main.ghci
+--restart utils/ghc-in-ghci/settings.ghci
diff --git a/utils/ghc-in-ghci/inner.ghci b/utils/ghc-in-ghci/inner.ghci
new file mode 100644
index 0000000000..72834c96b5
--- /dev/null
+++ b/utils/ghc-in-ghci/inner.ghci
@@ -0,0 +1 @@
+:set prompt "%s [inner]> "
diff --git a/utils/ghc-in-ghci/load-main.ghci b/utils/ghc-in-ghci/load-main.ghci
new file mode 100644
index 0000000000..a79855744e
--- /dev/null
+++ b/utils/ghc-in-ghci/load-main.ghci
@@ -0,0 +1 @@
+:load Main
diff --git a/utils/ghc-in-ghci/run.sh b/utils/ghc-in-ghci/run.sh
new file mode 100755
index 0000000000..2dda647903
--- /dev/null
+++ b/utils/ghc-in-ghci/run.sh
@@ -0,0 +1,36 @@
+#!/bin/sh -xe
+
+# Runs ghc-stage2 with GHCi settings that allow GHC to be loaded and run in the
+# interpreter. Options provided on the command-line will be passed directly to
+# the GHCi invocation.
+
+# Note that this script is intended to be run from the root of the GHC repo,
+# like this:
+
+# ./utils/ghc-in-ghci/run.sh
+
+# This is substantially faster than doing an actual compile, and so can aid in
+# tighter development iterations. It can be made even faster by specifying "-jN"
+# for parallelism. Typically choosing an N value close to the number of logical
+# CPU cores you have leads to faster loads. Here's how to specify -j:
+
+# ./utils/ghc-in-ghci/run.sh -j4
+
+# The script will also run `:load Main`, to load GHC's main module. After that,
+# running `main` will run an inner GHCi, because there is a default `:set args
+# --interactive ...`. To override this, use `:set args ...` or `:main ...`.
+
+# If you don't want to wait for `:load Main`, since you want to load some other
+# module, then you can use `Ctrl+C` to cancel the initial load.
+
+
+export _GHC_TOP_DIR=./inplace/lib
+
+exec ./inplace/bin/ghc-stage2 \
+    --interactive \
+    -ghci-script ./utils/ghc-in-ghci/settings.ghci \
+    -ghci-script ./utils/ghc-in-ghci/load-main.ghci \
+    -odir ./ghci-tmp \
+    -hidir ./ghci-tmp \
+    +RTS -A128m -RTS \
+    "$@"
diff --git a/utils/ghc-in-ghci/settings.ghci b/utils/ghc-in-ghci/settings.ghci
new file mode 100644
index 0000000000..1348274288
--- /dev/null
+++ b/utils/ghc-in-ghci/settings.ghci
@@ -0,0 +1,41 @@
+:set -icompiler/backpack
+:set -icompiler/basicTypes
+:set -icompiler/cmm
+:set -icompiler/codeGen
+:set -icompiler/coreSyn
+:set -icompiler/deSugar
+:set -icompiler/ghci
+:set -icompiler/hsSyn
+:set -icompiler/iface
+:set -icompiler/llvmGen
+:set -icompiler/main
+:set -icompiler/nativeGen
+:set -icompiler/parser
+:set -icompiler/prelude
+:set -icompiler/profiling
+:set -icompiler/rename
+:set -icompiler/simplCore
+:set -icompiler/simplStg
+:set -icompiler/specialise
+:set -icompiler/stgSyn
+:set -icompiler/stranal
+:set -icompiler/typecheck
+:set -icompiler/types
+:set -icompiler/utils
+:set -icompiler/vectorise
+:set -ighc
+:set -Icompiler
+:set -Icompiler/stage2
+:set -Icompiler/stage2/build
+:set -icompiler/stage2/build
+:set -Iincludes
+:set -Iincludes/dist-derivedconstants/header
+:set -package=ghc-boot-th
+:set -DSTAGE=2
+:set -DGHCI
+:set -DGHC_LOADED_INTO_GHCI
+:set -XNoImplicitPrelude
+
+-- Setup args so that running "main" will run ghci and set the prompt to
+-- indicate that it is an inner ghci.
+:set args --interactive -ghci-script utils/ghc-in-ghci/inner.ghci
-- 
2.23.0


From 0d4a5110531e496c76f681563f167ee94027816c Mon Sep 17 00:00:00 2001
From: Michael Sloan <mgsloan@gmail.com>
Date: Thu, 26 Jul 2018 17:21:08 -0400
Subject: [PATCH 02/12] Modifications to support loading GHC into GHCi

This change was previously part of
[D4904](https://phabricator.haskell.org/D4904), but is being split off
to aid in getting this reviewed and merged.

* The compiler code is built with `NoImplicitPrelude`, but GHCi's
  modules are incompatible with it. So, this adds the pragma to all GHCi
  modules that didn't have it, and adds imports of Prelude.

* In order to run GHC within itself, a `call of 'initGCStatistics`
  needed to be skipped. This uses CPP to skip it when
  `-DGHC_LOADED_INTO_GHCI` is set.

* There is an environment variable workaround suggested by Ben Gamari
  [1], where `_GHC_TOP_DIR` can be used to specify GHC's top dir if `-B`
  isn't provided.  This can be used to solve a problem where the GHC being
  run within GHCi attempts to look in `inplace/lib/lib/` instead of
  `inplace/lib/`.

[1]: https://phabricator.haskell.org/D4904#135438

Reviewers: goldfire, bgamari, erikd, alpmestan

Reviewed By: alpmestan

Subscribers: alpmestan, lelf, rwbarton, thomie, carter

Differential Revision: https://phabricator.haskell.org/D4986
---
 compiler/main/SysTools/BaseDir.hs             | 22 ++++++++++++++-----
 ghc/GHCi/Leak.hs                              |  2 ++
 ghc/GHCi/UI/Tags.hs                           |  5 +++--
 ghc/Main.hs                                   | 14 ++++++++++++
 ghc/ghc-bin.cabal.in                          |  5 +++++
 .../Language/Haskell/TH/Lib.hs                |  1 +
 .../Language/Haskell/TH/Lib/Internal.hs       |  1 +
 .../Language/Haskell/TH/Lib/Map.hs            |  2 ++
 .../Language/Haskell/TH/Quote.hs              |  1 +
 .../Language/Haskell/TH/Syntax.hs             |  1 +
 .../template-haskell/template-haskell.cabal   |  5 +++++
 11 files changed, 51 insertions(+), 8 deletions(-)

diff --git a/compiler/main/SysTools/BaseDir.hs b/compiler/main/SysTools/BaseDir.hs
index 85635df264..625baec8d9 100644
--- a/compiler/main/SysTools/BaseDir.hs
+++ b/compiler/main/SysTools/BaseDir.hs
@@ -22,6 +22,7 @@ import GhcPrelude
 
 import Panic
 
+import System.Environment (lookupEnv)
 import System.FilePath
 import Data.List
 
@@ -115,12 +116,21 @@ findTopDir :: Maybe String -- Maybe TopDir path (without the '-B' prefix).
            -> IO String    -- TopDir (in Unix format '/' separated)
 findTopDir (Just minusb) = return (normalise minusb)
 findTopDir Nothing
-    = do -- Get directory of executable
-         maybe_exec_dir <- getBaseDir
-         case maybe_exec_dir of
-             -- "Just" on Windows, "Nothing" on unix
-             Nothing  -> throwGhcExceptionIO (InstallationError "missing -B<dir> option")
-             Just dir -> return dir
+    = do -- The _GHC_TOP_DIR environment variable can be used to specify
+         -- the top dir when the -B argument is not specified. It is not
+         -- intended for use by users, it was added specifically for the
+         -- purpose of running GHC within GHCi.
+         maybe_env_top_dir <- lookupEnv "_GHC_TOP_DIR"
+         case maybe_env_top_dir of
+             Just env_top_dir -> return env_top_dir
+             Nothing -> do
+                 -- Get directory of executable
+                 maybe_exec_dir <- getBaseDir
+                 case maybe_exec_dir of
+                     -- "Just" on Windows, "Nothing" on unix
+                     Nothing -> throwGhcExceptionIO $
+                         InstallationError "missing -B<dir> option"
+                     Just dir -> return dir
 
 getBaseDir :: IO (Maybe String)
 #if defined(mingw32_HOST_OS)
diff --git a/ghc/GHCi/Leak.hs b/ghc/GHCi/Leak.hs
index 3f64b5dcf0..4904b2f18f 100644
--- a/ghc/GHCi/Leak.hs
+++ b/ghc/GHCi/Leak.hs
@@ -10,6 +10,8 @@ import GHC
 import Outputable
 import HscTypes
 import UniqDFM
+import Platform (target32Bit)
+import Prelude
 import System.Mem
 import System.Mem.Weak
 
diff --git a/ghc/GHCi/UI/Tags.hs b/ghc/GHCi/UI/Tags.hs
index d8af7f8718..09a8406d96 100644
--- a/ghc/GHCi/UI/Tags.hs
+++ b/ghc/GHCi/UI/Tags.hs
@@ -25,13 +25,14 @@ import OccName (pprOccName)
 import ConLike
 import MonadUtils
 
+import Control.Monad
 import Data.Function
+import Data.List
 import Data.Maybe
 import Data.Ord
 import DriverPhases
 import Panic
-import Data.List
-import Control.Monad
+import Prelude
 import System.Directory
 import System.IO
 import System.IO.Error
diff --git a/ghc/Main.hs b/ghc/Main.hs
index eda6a3d2a1..eff5c940b9 100644
--- a/ghc/Main.hs
+++ b/ghc/Main.hs
@@ -75,6 +75,7 @@ import Control.Monad
 import Data.Char
 import Data.List
 import Data.Maybe
+import Prelude
 
 -----------------------------------------------------------------------------
 -- ToDo:
@@ -936,5 +937,18 @@ people since we're linking GHC dynamically, but most things themselves
 link statically.
 -}
 
+-- If GHC_LOADED_INTO_GHCI is not set when GHC is loaded into GHCi, then
+-- running it causes an error like this:
+--
+-- Loading temp shared object failed:
+-- /tmp/ghc13836_0/libghc_1872.so: undefined symbol: initGCStatistics
+--
+-- Skipping the foreign call fixes this problem, and the outer GHCi
+-- should have already made this call anyway.
+#if defined(GHC_LOADED_INTO_GHCI)
+initGCStatistics :: IO ()
+initGCStatistics = return ()
+#else
 foreign import ccall safe "initGCStatistics"
   initGCStatistics :: IO ()
+#endif
diff --git a/ghc/ghc-bin.cabal.in b/ghc/ghc-bin.cabal.in
index d3cc40235d..0590bda6c4 100644
--- a/ghc/ghc-bin.cabal.in
+++ b/ghc/ghc-bin.cabal.in
@@ -83,3 +83,8 @@ Executable ghc
         CPP
         NondecreasingIndentation
         TupleSections
+
+    -- This should match the default-extensions used in 'ghc.cabal'. This way,
+    -- GHCi can be used to load it all at once.
+    Default-Extensions:
+        NoImplicitPrelude
diff --git a/libraries/template-haskell/Language/Haskell/TH/Lib.hs b/libraries/template-haskell/Language/Haskell/TH/Lib.hs
index b7966cefac..b0aa580d04 100644
--- a/libraries/template-haskell/Language/Haskell/TH/Lib.hs
+++ b/libraries/template-haskell/Language/Haskell/TH/Lib.hs
@@ -151,6 +151,7 @@ import Language.Haskell.TH.Lib.Internal hiding
 import Language.Haskell.TH.Syntax
 
 import Control.Monad (liftM2)
+import Prelude
 
 -- All definitions below represent the "old" API, since their definitions are
 -- different in Language.Haskell.TH.Lib.Internal. Please think carefully before
diff --git a/libraries/template-haskell/Language/Haskell/TH/Lib/Internal.hs b/libraries/template-haskell/Language/Haskell/TH/Lib/Internal.hs
index cac8ea8643..0ddfddf23a 100644
--- a/libraries/template-haskell/Language/Haskell/TH/Lib/Internal.hs
+++ b/libraries/template-haskell/Language/Haskell/TH/Lib/Internal.hs
@@ -18,6 +18,7 @@ import Language.Haskell.TH.Syntax hiding (Role, InjectivityAnn)
 import qualified Language.Haskell.TH.Syntax as TH
 import Control.Monad( liftM, liftM2 )
 import Data.Word( Word8 )
+import Prelude
 
 ----------------------------------------------------------
 -- * Type synonyms
diff --git a/libraries/template-haskell/Language/Haskell/TH/Lib/Map.hs b/libraries/template-haskell/Language/Haskell/TH/Lib/Map.hs
index ac241515b8..b11139c2cb 100644
--- a/libraries/template-haskell/Language/Haskell/TH/Lib/Map.hs
+++ b/libraries/template-haskell/Language/Haskell/TH/Lib/Map.hs
@@ -16,6 +16,8 @@ module Language.Haskell.TH.Lib.Map
     , Language.Haskell.TH.Lib.Map.lookup
     ) where
 
+import Prelude
+
 data Map k a  = Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)
               | Tip
 
diff --git a/libraries/template-haskell/Language/Haskell/TH/Quote.hs b/libraries/template-haskell/Language/Haskell/TH/Quote.hs
index 91e37399e6..4ff5a2041b 100644
--- a/libraries/template-haskell/Language/Haskell/TH/Quote.hs
+++ b/libraries/template-haskell/Language/Haskell/TH/Quote.hs
@@ -21,6 +21,7 @@ module Language.Haskell.TH.Quote(
     ) where
 
 import Language.Haskell.TH.Syntax
+import Prelude
 
 -- | The 'QuasiQuoter' type, a value @q@ of this type can be used
 -- in the syntax @[q| ... string to parse ...|]@.  In fact, for
diff --git a/libraries/template-haskell/Language/Haskell/TH/Syntax.hs b/libraries/template-haskell/Language/Haskell/TH/Syntax.hs
index b6f7c34673..1fb248e9d9 100644
--- a/libraries/template-haskell/Language/Haskell/TH/Syntax.hs
+++ b/libraries/template-haskell/Language/Haskell/TH/Syntax.hs
@@ -41,6 +41,7 @@ import GHC.Lexeme       ( startsVarSym, startsVarId )
 import GHC.ForeignSrcLang.Type
 import Language.Haskell.TH.LanguageExtensions
 import Numeric.Natural
+import Prelude
 
 import qualified Control.Monad.Fail as Fail
 
diff --git a/libraries/template-haskell/template-haskell.cabal b/libraries/template-haskell/template-haskell.cabal
index 590babd2f4..e059a98a39 100644
--- a/libraries/template-haskell/template-haskell.cabal
+++ b/libraries/template-haskell/template-haskell.cabal
@@ -60,3 +60,8 @@ Library
     -- We need to set the unit ID to template-haskell (without a
     -- version number) as it's magic.
     ghc-options: -this-unit-id template-haskell
+
+    -- This should match the default-extensions used in 'ghc.cabal'. This way,
+    -- GHCi can be used to load it along with the compiler.
+    Default-Extensions:
+        NoImplicitPrelude
-- 
2.23.0


From ce8916b5441e19496d06b9fe8912992d514441b6 Mon Sep 17 00:00:00 2001
From: Michael Sloan <mgsloan@gmail.com>
Date: Mon, 6 Aug 2018 19:19:47 +0200
Subject: [PATCH 03/12] Use -fobject-code in the GHCi script for loading GHC

Summary:
My very last commit to D4904 removed -fobject-code.  I should have tested this
more thoroughly, because it is required to do a fresh ghci load, as some code
uses unboxed tuples.

One of my motivations for doing this was that if you run the script without
passing -odir / -hidir, it would pollute the source tree with .hi and .o files.
This also appeared to break subsequent builds. I've made it much less likely
that this will happen by instead specifying -odir and -hidir within the ghci
script rather than on the commandline.

I plan to open a separate diff which adds a test that these scripts work.

Until this patch is merged, the workaround is to do `./utils/ghc-in-ghci/run.sh -fobject-code`

Reviewers: bgamari, alpmestan, monoidal

Reviewed By: alpmestan, monoidal

Subscribers: alpmestan, rwbarton, thomie, carter

Differential Revision: https://phabricator.haskell.org/D5015
---
 .gitignore                      | 5 +++++
 utils/ghc-in-ghci/run.sh        | 2 --
 utils/ghc-in-ghci/settings.ghci | 6 ++++++
 3 files changed, 11 insertions(+), 2 deletions(-)

diff --git a/.gitignore b/.gitignore
index 7e2425c964..c72d044473 100644
--- a/.gitignore
+++ b/.gitignore
@@ -204,3 +204,8 @@ GIT_COMMIT_ID
 
 # Should be equal to testdir_suffix from testsuite/driver/testlib.py.
 *.run
+
+# -----------------------------------------------------------------------------
+# Output of ghc-in-ghci
+
+/.ghci-objects/
\ No newline at end of file
diff --git a/utils/ghc-in-ghci/run.sh b/utils/ghc-in-ghci/run.sh
index 2dda647903..521458f67d 100755
--- a/utils/ghc-in-ghci/run.sh
+++ b/utils/ghc-in-ghci/run.sh
@@ -30,7 +30,5 @@ exec ./inplace/bin/ghc-stage2 \
     --interactive \
     -ghci-script ./utils/ghc-in-ghci/settings.ghci \
     -ghci-script ./utils/ghc-in-ghci/load-main.ghci \
-    -odir ./ghci-tmp \
-    -hidir ./ghci-tmp \
     +RTS -A128m -RTS \
     "$@"
diff --git a/utils/ghc-in-ghci/settings.ghci b/utils/ghc-in-ghci/settings.ghci
index 1348274288..8f5ba6e031 100644
--- a/utils/ghc-in-ghci/settings.ghci
+++ b/utils/ghc-in-ghci/settings.ghci
@@ -36,6 +36,12 @@
 :set -DGHC_LOADED_INTO_GHCI
 :set -XNoImplicitPrelude
 
+-- -fobject-code is required because bytecode doesn't support unboxed tuples
+-- https://ghc.haskell.org/trac/ghc/ticket/1257
+:set -odir ./.ghci-objects
+:set -hidir ./.ghci-objects
+:set -fobject-code
+
 -- Setup args so that running "main" will run ghci and set the prompt to
 -- indicate that it is an inner ghci.
 :set args --interactive -ghci-script utils/ghc-in-ghci/inner.ghci
-- 
2.23.0


From 5b13a10d77a29cf1ae6fd53ec1e870d7041d342b Mon Sep 17 00:00:00 2001
From: Joachim Breitner <mail@joachim-breitner.de>
Date: Wed, 3 Oct 2018 15:36:55 +0200
Subject: [PATCH 04/12] D5079

---
 compiler/basicTypes/Module.hs                 | 60 +++++++++++--------
 compiler/coreSyn/CorePrep.hs                  |  5 +-
 compiler/ghc.mk                               |  2 -
 compiler/main/DynFlags.hs                     |  4 ++
 compiler/main/Packages.hs                     | 48 ++++++++-------
 compiler/prelude/PrelNames.hs                 | 49 ++++++++++-----
 libraries/integer-gmp/integer-gmp.cabal       |  5 +-
 libraries/integer-simple/integer-simple.cabal |  5 +-
 8 files changed, 110 insertions(+), 68 deletions(-)

diff --git a/compiler/basicTypes/Module.hs b/compiler/basicTypes/Module.hs
index 1851496af1..339cb0f4f9 100644
--- a/compiler/basicTypes/Module.hs
+++ b/compiler/basicTypes/Module.hs
@@ -137,7 +137,6 @@ module Module
 
 import GhcPrelude
 
-import Config
 import Outputable
 import Unique
 import UniqFM
@@ -1042,36 +1041,45 @@ parseModSubst = Parse.between (Parse.char '[') (Parse.char ']')
            return (k, v)
 
 
--- -----------------------------------------------------------------------------
--- $wired_in_packages
--- Certain packages are known to the compiler, in that we know about certain
--- entities that reside in these packages, and the compiler needs to
--- declare static Modules and Names that refer to these packages.  Hence
--- the wired-in packages can't include version numbers, since we don't want
--- to bake the version numbers of these packages into GHC.
---
--- So here's the plan.  Wired-in packages are still versioned as
--- normal in the packages database, and you can still have multiple
--- versions of them installed.  However, for each invocation of GHC,
--- only a single instance of each wired-in package will be recognised
--- (the desired one is selected via @-package@\/@-hide-package@), and GHC
--- will use the unversioned 'UnitId' below when referring to it,
--- including in .hi files and object file symbols.  Unselected
--- versions of wired-in packages will be ignored, as will any other
--- package that depends directly or indirectly on it (much as if you
--- had used @-ignore-package@).
-
--- Make sure you change 'Packages.findWiredInPackages' if you add an entry here
+{-
+Note [Wired-in packages]
+~~~~~~~~~~~~~~~~~~~~~~~~
+
+Certain packages are known to the compiler, in that we know about certain
+entities that reside in these packages, and the compiler needs to
+declare static Modules and Names that refer to these packages.  Hence
+the wired-in packages can't include version numbers in their package UnitId,
+since we don't want to bake the version numbers of these packages into GHC.
+
+So here's the plan.  Wired-in packages are still versioned as
+normal in the packages database, and you can still have multiple
+versions of them installed. To the user, everything looks normal.
+
+However, for each invocation of GHC, only a single instance of each wired-in
+package will be recognised (the desired one is selected via
+@-package@\/@-hide-package@), and GHC will internall pretend that it has the
+*unversioned* 'UnitId', including in .hi files and object file symbols.
+
+Unselected versions of wired-in packages will be ignored, as will any other
+package that depends directly or indirectly on it (much as if you
+had used @-ignore-package@).
+
+The affected packages are compiled with, e.g., @-this-unit-id base@, so that
+the symbols in the object files have the unversioned unit id in their name.
+
+Make sure you change 'Packages.findWiredInPackages' if you add an entry here.
+
+For `integer-gmp`/`integer-simple` we also change the base name to
+`integer-wired-in`, but this is fundamentally no different.
+See Note [The integer library] in PrelNames.
+-}
 
 integerUnitId, primUnitId,
   baseUnitId, rtsUnitId,
   thUnitId, mainUnitId, thisGhcUnitId, interactiveUnitId  :: UnitId
 primUnitId        = fsToUnitId (fsLit "ghc-prim")
-integerUnitId     = fsToUnitId (fsLit n)
-  where
-    n = case cIntegerLibraryType of
-        IntegerGMP    -> "integer-gmp"
-        IntegerSimple -> "integer-simple"
+integerUnitId     = fsToUnitId (fsLit "integer-wired-in")
+   -- See Note [The integer library] in PrelNames
 baseUnitId        = fsToUnitId (fsLit "base")
 rtsUnitId         = fsToUnitId (fsLit "rts")
 thUnitId          = fsToUnitId (fsLit "template-haskell")
diff --git a/compiler/coreSyn/CorePrep.hs b/compiler/coreSyn/CorePrep.hs
index 6efebbedb2..19b6364e1e 100644
--- a/compiler/coreSyn/CorePrep.hs
+++ b/compiler/coreSyn/CorePrep.hs
@@ -1487,14 +1487,15 @@ lookupMkNaturalName dflags hsc_env
     = guardNaturalUse dflags $ liftM tyThingId $
       lookupGlobal hsc_env mkNaturalName
 
+-- See Note [The integer library] in PrelNames
 lookupIntegerSDataConName :: DynFlags -> HscEnv -> IO (Maybe DataCon)
-lookupIntegerSDataConName dflags hsc_env = case cIntegerLibraryType of
+lookupIntegerSDataConName dflags hsc_env = case integerLibrary dflags of
     IntegerGMP -> guardIntegerUse dflags $ liftM (Just . tyThingDataCon) $
                   lookupGlobal hsc_env integerSDataConName
     IntegerSimple -> return Nothing
 
 lookupNaturalSDataConName :: DynFlags -> HscEnv -> IO (Maybe DataCon)
-lookupNaturalSDataConName dflags hsc_env = case cIntegerLibraryType of
+lookupNaturalSDataConName dflags hsc_env = case integerLibrary dflags of
     IntegerGMP -> guardNaturalUse dflags $ liftM (Just . tyThingDataCon) $
                   lookupGlobal hsc_env naturalSDataConName
     IntegerSimple -> return Nothing
diff --git a/compiler/ghc.mk b/compiler/ghc.mk
index 9bc6b3f278..8a4cc4317d 100644
--- a/compiler/ghc.mk
+++ b/compiler/ghc.mk
@@ -84,8 +84,6 @@ compiler/stage%/build/Config.hs : mk/config.mk mk/project.mk | $$(dir $$@)/.
 	@echo 'cBooterVersion        = "$(GhcVersion)"'                     >> $@
 	@echo 'cStage                :: String'                             >> $@
 	@echo 'cStage                = show (STAGE :: Int)'                 >> $@
-	@echo 'cIntegerLibrary       :: String'                             >> $@
-	@echo 'cIntegerLibrary       = "$(INTEGER_LIBRARY)"'                >> $@
 	@echo 'cIntegerLibraryType   :: IntegerLibrary'                     >> $@
 ifeq "$(INTEGER_LIBRARY)" "integer-gmp"
 	@echo 'cIntegerLibraryType   = IntegerGMP'                          >> $@
diff --git a/compiler/main/DynFlags.hs b/compiler/main/DynFlags.hs
index 539132653e..c1dd9ceb6c 100644
--- a/compiler/main/DynFlags.hs
+++ b/compiler/main/DynFlags.hs
@@ -848,6 +848,9 @@ data DynFlags = DynFlags {
   ghcLink               :: GhcLink,
   hscTarget             :: HscTarget,
   settings              :: Settings,
+  integerLibrary        :: IntegerLibrary,
+    -- ^ IntegerGMP or IntegerSimple. Set at configure time, but may be overriden
+    --   by GHC-API users. See Note [The integer library] in PrelNames
   llvmTargets           :: LlvmTargets,
   llvmPasses            :: LlvmPasses,
   verbosity             :: Int,         -- ^ Verbosity level: see Note [Verbosity levels]
@@ -1753,6 +1756,7 @@ defaultDynFlags mySettings (myLlvmTargets, myLlvmPasses) =
         ghcMode                 = CompManager,
         ghcLink                 = LinkBinary,
         hscTarget               = defaultHscTarget (sTargetPlatform mySettings),
+        integerLibrary          = cIntegerLibraryType,
         verbosity               = 0,
         optLevel                = 0,
         debugLevel              = 0,
diff --git a/compiler/main/Packages.hs b/compiler/main/Packages.hs
index aa9db19e99..ebf7011447 100644
--- a/compiler/main/Packages.hs
+++ b/compiler/main/Packages.hs
@@ -954,12 +954,15 @@ pprTrustFlag flag = case flag of
 
 -- -----------------------------------------------------------------------------
 -- Wired-in packages
+--
+-- See Note [Wired-in packages] in Module
 
-wired_in_pkgids :: [String]
-wired_in_pkgids = map unitIdString wiredInUnitIds
-
+type WiredInUnitId = String
 type WiredPackagesMap = Map WiredUnitId WiredUnitId
 
+wired_in_pkgids :: [WiredInUnitId]
+wired_in_pkgids = map unitIdString wiredInUnitIds
+
 findWiredInPackages
    :: DynFlags
    -> PackagePrecedenceIndex
@@ -970,12 +973,15 @@ findWiredInPackages
           WiredPackagesMap) -- map from unit id to wired identity
 
 findWiredInPackages dflags prec_map pkgs vis_map = do
-  --
   -- Now we must find our wired-in packages, and rename them to
-  -- their canonical names (eg. base-1.0 ==> base).
-  --
+  -- their canonical names (eg. base-1.0 ==> base), as described
+  -- in Note [Wired-in packages] in Module
   let
-        matches :: PackageConfig -> String -> Bool
+        matches :: PackageConfig -> WiredInUnitId -> Bool
+        pc `matches` pid
+            -- See Note [The integer library] in PrelNames
+            | pid == unitIdString integerUnitId
+            = packageNameString pc `elem` ["integer-gmp", "integer-simple"]
         pc `matches` pid = packageNameString pc == pid
 
         -- find which package corresponds to each wired-in package
@@ -995,8 +1001,8 @@ findWiredInPackages dflags prec_map pkgs vis_map = do
         -- this works even when there is no exposed wired in package
         -- available.
         --
-        findWiredInPackage :: [PackageConfig] -> String
-                           -> IO (Maybe PackageConfig)
+        findWiredInPackage :: [PackageConfig] -> WiredInUnitId
+                           -> IO (Maybe (WiredInUnitId, PackageConfig))
         findWiredInPackage pkgs wired_pkg =
            let all_ps = [ p | p <- pkgs, p `matches` wired_pkg ]
                all_exposed_ps =
@@ -1015,20 +1021,19 @@ findWiredInPackages dflags prec_map pkgs vis_map = do
                                  <> text " not found."
                           return Nothing
                 pick :: PackageConfig
-                     -> IO (Maybe PackageConfig)
+                     -> IO (Maybe (WiredInUnitId, PackageConfig))
                 pick pkg = do
                         debugTraceMsg dflags 2 $
                             text "wired-in package "
                                  <> text wired_pkg
                                  <> text " mapped to "
                                  <> ppr (unitId pkg)
-                        return (Just pkg)
+                        return (Just (wired_pkg, pkg))
 
 
   mb_wired_in_pkgs <- mapM (findWiredInPackage pkgs) wired_in_pkgids
   let
         wired_in_pkgs = catMaybes mb_wired_in_pkgs
-        wired_in_ids = mapMaybe definitePackageConfigId wired_in_pkgs
 
         -- this is old: we used to assume that if there were
         -- multiple versions of wired-in packages installed that
@@ -1044,18 +1049,17 @@ findWiredInPackages dflags prec_map pkgs vis_map = do
         -}
 
         wiredInMap :: Map WiredUnitId WiredUnitId
-        wiredInMap = foldl' add_mapping Map.empty pkgs
-          where add_mapping m pkg
-                  | Just key <- definitePackageConfigId pkg
-                  , key `elem` wired_in_ids
-                  = Map.insert key (DefUnitId (stringToInstalledUnitId (packageNameString pkg))) m
-                  | otherwise = m
+        wiredInMap = Map.fromList
+          [ (key, DefUnitId (stringToInstalledUnitId wiredInUnitId))
+          | (wiredInUnitId, pkg) <- wired_in_pkgs
+          , Just key <- pure $ definitePackageConfigId pkg
+          ]
 
         updateWiredInDependencies pkgs = map (upd_deps . upd_pkg) pkgs
           where upd_pkg pkg
                   | Just def_uid <- definitePackageConfigId pkg
-                  , def_uid `elem` wired_in_ids
-                  = let PackageName fs = packageName pkg
+                  , Just wiredInUnitId <- Map.lookup def_uid wiredInMap
+                  = let fs = installedUnitIdFS (unDefUnitId wiredInUnitId)
                     in pkg {
                       unitId = fsToInstalledUnitId fs,
                       componentId = ComponentId fs
@@ -1075,7 +1079,9 @@ findWiredInPackages dflags prec_map pkgs vis_map = do
 
 -- Helper functions for rewiring Module and UnitId.  These
 -- rewrite UnitIds of modules in wired-in packages to the form known to the
--- compiler. For instance, base-4.9.0.0 will be rewritten to just base, to match
+-- compiler, as described in Note [Wired-in packages] in Module.
+--
+-- For instance, base-4.9.0.0 will be rewritten to just base, to match
 -- what appears in PrelNames.
 
 upd_wired_in_mod :: WiredPackagesMap -> Module -> Module
diff --git a/compiler/prelude/PrelNames.hs b/compiler/prelude/PrelNames.hs
index d971a8be90..5adfe38c74 100644
--- a/compiler/prelude/PrelNames.hs
+++ b/compiler/prelude/PrelNames.hs
@@ -110,6 +110,36 @@ by the user. For those things that *can* appear in source programs,
      original-name cache.
 
      See also Note [Built-in syntax and the OrigNameCache]
+
+
+Note [The integer library]
+~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Clearly, we need to know the names of various definitions of the integer
+library, e.g. the type itself, `mkInteger` etc. But there are two possible
+implementations of the integer library:
+
+ * integer-gmp (fast, but uses libgmp, which may not be available on all
+   targets and is GPL licensed)
+ * integer-simple (slow, but pure Haskell and BSD-licensed)
+
+We want the compiler to work with either one. The way we achieve this is:
+
+ * When compiling the integer-{gmp,simple} library, we pass
+     -this-unit-id  integer-wired-in
+   to GHC (see the cabal file libraries/integer-{gmp,simple}.
+ * This way, GHC can use just this UnitID (see Module.integerUnitId) when
+   generating code, and the linker will succeed.
+
+Unfortuately, the abstraction is not complete: When using integer-gmp, we
+really want to use the S# constructor directly. This is controlled by
+the `integerLibrary` field of `DynFlags`: If it is IntegerGMP, we use
+this constructor directly (see  CorePrep.lookupIntegerSDataConName)
+
+When GHC reads the package data base, it (internally only) pretends it has UnitId
+`integer-wired-in` instead of the actual UnitId (which includes the version
+number); just like for `base` and other packages, as described in
+Note [Wired-in packages] in Module. This is done in Packages.findWiredInPackages.
 -}
 
 {-# LANGUAGE CPP #-}
@@ -136,8 +166,6 @@ import Unique
 import Name
 import SrcLoc
 import FastString
-import Config ( cIntegerLibraryType, IntegerLibrary(..) )
-import Panic ( panic )
 
 {-
 ************************************************************************
@@ -355,6 +383,7 @@ basicKnownKeyNames
         gcdIntegerName, lcmIntegerName,
         andIntegerName, orIntegerName, xorIntegerName, complementIntegerName,
         shiftLIntegerName, shiftRIntegerName, bitIntegerName,
+        integerSDataConName,naturalSDataConName,
 
         -- Natural
         naturalTyConName,
@@ -436,9 +465,7 @@ basicKnownKeyNames
         -- homogeneous equality
         , eqTyConName
 
-    ] ++ case cIntegerLibraryType of
-           IntegerGMP    -> [integerSDataConName,naturalSDataConName]
-           IntegerSimple -> []
+    ]
 
 genericTyConNames :: [Name]
 genericTyConNames = [
@@ -1123,11 +1150,8 @@ integerTyConName, mkIntegerName, integerSDataConName,
     gcdIntegerName, lcmIntegerName,
     andIntegerName, orIntegerName, xorIntegerName, complementIntegerName,
     shiftLIntegerName, shiftRIntegerName, bitIntegerName :: Name
-integerTyConName      = tcQual  gHC_INTEGER_TYPE (fsLit "Integer")           integerTyConKey
-integerSDataConName   = dcQual gHC_INTEGER_TYPE (fsLit n)                    integerSDataConKey
-  where n = case cIntegerLibraryType of
-            IntegerGMP    -> "S#"
-            IntegerSimple -> panic "integerSDataConName evaluated for integer-simple"
+integerTyConName      = tcQual gHC_INTEGER_TYPE (fsLit "Integer")           integerTyConKey
+integerSDataConName   = dcQual gHC_INTEGER_TYPE (fsLit "S#")                integerSDataConKey
 mkIntegerName         = varQual gHC_INTEGER_TYPE (fsLit "mkInteger")         mkIntegerIdKey
 integerToWord64Name   = varQual gHC_INTEGER_TYPE (fsLit "integerToWord64")   integerToWord64IdKey
 integerToInt64Name    = varQual gHC_INTEGER_TYPE (fsLit "integerToInt64")    integerToInt64IdKey
@@ -1174,10 +1198,7 @@ bitIntegerName        = varQual gHC_INTEGER_TYPE (fsLit "bitInteger")        bit
 -- GHC.Natural types
 naturalTyConName, naturalSDataConName :: Name
 naturalTyConName     = tcQual gHC_NATURAL (fsLit "Natural") naturalTyConKey
-naturalSDataConName  = dcQual gHC_NATURAL (fsLit n)         naturalSDataConKey
-  where n = case cIntegerLibraryType of
-            IntegerGMP    -> "NatS#"
-            IntegerSimple -> panic "naturalSDataConName evaluated for integer-simple"
+naturalSDataConName  = dcQual gHC_NATURAL (fsLit "NatS#")   naturalSDataConKey
 
 naturalFromIntegerName :: Name
 naturalFromIntegerName = varQual gHC_NATURAL (fsLit "naturalFromInteger") naturalFromIntegerIdKey
diff --git a/libraries/integer-gmp/integer-gmp.cabal b/libraries/integer-gmp/integer-gmp.cabal
index 5d2f89039c..52834bb4ea 100644
--- a/libraries/integer-gmp/integer-gmp.cabal
+++ b/libraries/integer-gmp/integer-gmp.cabal
@@ -60,7 +60,10 @@ library
     UnliftedFFITypes
   build-depends:       ghc-prim ^>= 0.5.1.0
   hs-source-dirs:      src/
-  ghc-options: -this-unit-id integer-gmp -Wall
+  -- We need to set the unit ID to integer-wired-in
+  -- (without a version number) as it's magic.
+  -- See Note [The integer library] in PrelNames
+  ghc-options: -this-unit-id integer-wired-in -Wall
   cc-options: -std=c99 -Wall
 
   include-dirs: include
diff --git a/libraries/integer-simple/integer-simple.cabal b/libraries/integer-simple/integer-simple.cabal
index 231619c6c7..96c2e2358e 100644
--- a/libraries/integer-simple/integer-simple.cabal
+++ b/libraries/integer-simple/integer-simple.cabal
@@ -26,6 +26,7 @@ Library
     other-modules: GHC.Integer.Type
     default-extensions: CPP, MagicHash, BangPatterns, UnboxedTuples,
                 UnliftedFFITypes, NoImplicitPrelude
-    -- We need to set the unit ID to integer-simple
+    -- We need to set the unit ID to integer-wired-in
     -- (without a version number) as it's magic.
-    ghc-options: -this-unit-id integer-simple -Wall
+    -- See Note [The integer library] in PrelNames
+    ghc-options: -this-unit-id integer-wired-in -Wall
-- 
2.23.0


From 275b9ed1e52ed351009a451623edac6f28980553 Mon Sep 17 00:00:00 2001
From: Joachim Breitner <mail@joachim-breitner.de>
Date: Mon, 20 Aug 2018 14:44:23 -0700
Subject: [PATCH 05/12] D5082

---
 compiler/ghc.mk                   |  8 ----
 compiler/ghci/ByteCodeItbls.hs    |  4 +-
 compiler/main/DynFlags.hs         |  8 ++--
 compiler/main/SysTools.hs         |  8 +---
 compiler/utils/Util.hs            |  8 ----
 libraries/ghci/GHCi/InfoTable.hsc | 66 ++++++++++++++-----------------
 libraries/ghci/GHCi/Message.hs    |  7 ++--
 libraries/ghci/GHCi/Run.hs        |  4 +-
 8 files changed, 42 insertions(+), 71 deletions(-)

diff --git a/compiler/ghc.mk b/compiler/ghc.mk
index 8a4cc4317d..f846f76b22 100644
--- a/compiler/ghc.mk
+++ b/compiler/ghc.mk
@@ -334,14 +334,6 @@ endif
 ifeq "$(GhcWithInterpreter)" "YES"
 compiler_stage2_CONFIGURE_OPTS += --flags=ghci
 
-ifeq "$(GhcEnableTablesNextToCode) $(GhcUnregisterised)" "YES NO"
-# Should GHCI be building info tables in the TABLES_NEXT_TO_CODE style
-# or not?
-# XXX This should logically be a CPP option, but there doesn't seem to
-# be a flag for that
-compiler_stage2_CONFIGURE_OPTS += --ghc-option=-DGHCI_TABLES_NEXT_TO_CODE
-endif
-
 # Should the debugger commands be enabled?
 ifeq "$(GhciWithDebugger)" "YES"
 compiler_stage2_CONFIGURE_OPTS += --ghc-option=-DDEBUGGER
diff --git a/compiler/ghci/ByteCodeItbls.hs b/compiler/ghci/ByteCodeItbls.hs
index 7381c8f926..c17f213365 100644
--- a/compiler/ghci/ByteCodeItbls.hs
+++ b/compiler/ghci/ByteCodeItbls.hs
@@ -71,6 +71,8 @@ make_constr_itbls hsc_env cons =
 
          descr = dataConIdentity dcon
 
-     r <- iservCmd hsc_env (MkConInfoTable ptrs' nptrs_really
+         tables_next_to_code = tablesNextToCode dflags
+
+     r <- iservCmd hsc_env (MkConInfoTable tables_next_to_code ptrs' nptrs_really
                               conNo (tagForCon dflags dcon) descr)
      return (getName dcon, ItblPtr r)
diff --git a/compiler/main/DynFlags.hs b/compiler/main/DynFlags.hs
index c1dd9ceb6c..247ce93872 100644
--- a/compiler/main/DynFlags.hs
+++ b/compiler/main/DynFlags.hs
@@ -57,7 +57,7 @@ module DynFlags (
         fFlags, fLangFlags, xFlags,
         wWarningFlags,
         dynFlagDependencies,
-        tablesNextToCode, mkTablesNextToCode,
+        mkTablesNextToCode,
         makeDynFlagsConsistent,
         shouldUseColor,
         shouldUseHexWordLiterals,
@@ -851,6 +851,7 @@ data DynFlags = DynFlags {
   integerLibrary        :: IntegerLibrary,
     -- ^ IntegerGMP or IntegerSimple. Set at configure time, but may be overriden
     --   by GHC-API users. See Note [The integer library] in PrelNames
+  tablesNextToCode      :: Bool,
   llvmTargets           :: LlvmTargets,
   llvmPasses            :: LlvmPasses,
   verbosity             :: Int,         -- ^ Verbosity level: see Note [Verbosity levels]
@@ -1494,10 +1495,6 @@ defaultObjectTarget platform
   | cGhcWithNativeCodeGen == "YES"      =  HscAsm
   | otherwise                           =  HscLlvm
 
-tablesNextToCode :: DynFlags -> Bool
-tablesNextToCode dflags
-    = mkTablesNextToCode (platformUnregisterised (targetPlatform dflags))
-
 -- Determines whether we will be compiling
 -- info tables that reside just before the entry code, or with an
 -- indirection to the entry code.  See TABLES_NEXT_TO_CODE in
@@ -1757,6 +1754,7 @@ defaultDynFlags mySettings (myLlvmTargets, myLlvmPasses) =
         ghcLink                 = LinkBinary,
         hscTarget               = defaultHscTarget (sTargetPlatform mySettings),
         integerLibrary          = cIntegerLibraryType,
+        tablesNextToCode        = mkTablesNextToCode (platformUnregisterised (sTargetPlatform mySettings)),
         verbosity               = 0,
         optLevel                = 0,
         debugLevel              = 0,
diff --git a/compiler/main/SysTools.hs b/compiler/main/SysTools.hs
index d987d7dcd0..cc7e4205c9 100644
--- a/compiler/main/SysTools.hs
+++ b/compiler/main/SysTools.hs
@@ -201,15 +201,9 @@ initSysTools mbMinusB
        let unreg_gcc_args = if targetUnregisterised
                             then ["-DNO_REGS", "-DUSE_MINIINTERPRETER"]
                             else []
-           -- TABLES_NEXT_TO_CODE affects the info table layout.
-           tntc_gcc_args
-            | mkTablesNextToCode targetUnregisterised
-               = ["-DTABLES_NEXT_TO_CODE"]
-            | otherwise = []
            cpp_args= map Option (words cpp_args_str)
            gcc_args = map Option (words gcc_args_str
-                               ++ unreg_gcc_args
-                               ++ tntc_gcc_args)
+                               ++ unreg_gcc_args)
        ldSupportsCompactUnwind <- getBooleanSetting "ld supports compact unwind"
        ldSupportsBuildId       <- getBooleanSetting "ld supports build-id"
        ldSupportsFilelist      <- getBooleanSetting "ld supports filelist"
diff --git a/compiler/utils/Util.hs b/compiler/utils/Util.hs
index 9523c08ff2..07ac253b61 100644
--- a/compiler/utils/Util.hs
+++ b/compiler/utils/Util.hs
@@ -10,7 +10,6 @@
 module Util (
         -- * Flags dependent on the compiler build
         ghciSupported, debugIsOn, ncgDebugIsOn,
-        ghciTablesNextToCode,
         isWindowsHost, isDarwinHost,
 
         -- * General list processing
@@ -205,13 +204,6 @@ ncgDebugIsOn = True
 ncgDebugIsOn = False
 #endif
 
-ghciTablesNextToCode :: Bool
-#if defined(GHCI_TABLES_NEXT_TO_CODE)
-ghciTablesNextToCode = True
-#else
-ghciTablesNextToCode = False
-#endif
-
 isWindowsHost :: Bool
 #if defined(mingw32_HOST_OS)
 isWindowsHost = True
diff --git a/libraries/ghci/GHCi/InfoTable.hsc b/libraries/ghci/GHCi/InfoTable.hsc
index ca5757257c..f495d56475 100644
--- a/libraries/ghci/GHCi/InfoTable.hsc
+++ b/libraries/ghci/GHCi/InfoTable.hsc
@@ -23,19 +23,13 @@ import GHC.Exts
 import GHC.Exts.Heap
 #endif
 
-ghciTablesNextToCode :: Bool
-#ifdef TABLES_NEXT_TO_CODE
-ghciTablesNextToCode = True
-#else
-ghciTablesNextToCode = False
-#endif
-
 #ifdef GHCI /* To end */
 -- NOTE: Must return a pointer acceptable for use in the header of a closure.
 -- If tables_next_to_code is enabled, then it must point the the 'code' field.
 -- Otherwise, it should point to the start of the StgInfoTable.
 mkConInfoTable
-   :: Int     -- ptr words
+   :: Bool    -- TABLES_NEXT_TO_CODE
+   -> Int     -- ptr words
    -> Int     -- non-ptr words
    -> Int     -- constr tag
    -> Int     -- pointer tag
@@ -44,20 +38,20 @@ mkConInfoTable
       -- resulting info table is allocated with allocateExec(), and
       -- should be freed with freeExec().
 
-mkConInfoTable ptr_words nonptr_words tag ptrtag con_desc =
-  castFunPtrToPtr <$> newExecConItbl itbl con_desc
+mkConInfoTable tables_next_to_code ptr_words nonptr_words tag ptrtag con_desc =
+  castFunPtrToPtr <$> newExecConItbl tables_next_to_code itbl con_desc
   where
      entry_addr = interpConstrEntry !! ptrtag
      code' = mkJumpToAddr entry_addr
      itbl  = StgInfoTable {
-                 entry = if ghciTablesNextToCode
+                 entry = if tables_next_to_code
                          then Nothing
                          else Just entry_addr,
                  ptrs  = fromIntegral ptr_words,
                  nptrs = fromIntegral nonptr_words,
                  tipe  = CONSTR,
                  srtlen = fromIntegral tag,
-                 code  = if ghciTablesNextToCode
+                 code  = if tables_next_to_code
                          then Just code'
                          else Nothing
               }
@@ -318,38 +312,38 @@ data StgConInfoTable = StgConInfoTable {
 
 
 pokeConItbl
-  :: Ptr StgConInfoTable -> Ptr StgConInfoTable -> StgConInfoTable
+  :: Bool -> Ptr StgConInfoTable -> Ptr StgConInfoTable -> StgConInfoTable
   -> IO ()
-pokeConItbl wr_ptr _ex_ptr itbl = do
-#if defined(TABLES_NEXT_TO_CODE)
-  -- Write the offset to the con_desc from the end of the standard InfoTable
-  -- at the first byte.
-  let con_desc_offset = conDesc itbl `minusPtr` (_ex_ptr `plusPtr` conInfoTableSizeB)
-  (#poke StgConInfoTable, con_desc) wr_ptr con_desc_offset
-#else
-  -- Write the con_desc address after the end of the info table.
-  -- Use itblSize because CPP will not pick up PROFILING when calculating
-  -- the offset.
-  pokeByteOff wr_ptr itblSize (conDesc itbl)
-#endif
+pokeConItbl tables_next_to_code wr_ptr _ex_ptr itbl = do
+  if tables_next_to_code
+  then do
+      -- Write the offset to the con_desc from the end of the standard InfoTable
+      -- at the first byte.
+      let con_desc_offset = conDesc itbl `minusPtr` (_ex_ptr `plusPtr` conInfoTableSizeB)
+      (#poke StgConInfoTable, con_desc) wr_ptr con_desc_offset
+  else do
+      -- Write the con_desc address after the end of the info table.
+      -- Use itblSize because CPP will not pick up PROFILING when calculating
+      -- the offset.
+      pokeByteOff wr_ptr itblSize (conDesc itbl)
   pokeItbl (wr_ptr `plusPtr` (#offset StgConInfoTable, i)) (infoTable itbl)
 
-sizeOfEntryCode :: Int
-sizeOfEntryCode
-  | not ghciTablesNextToCode = 0
+sizeOfEntryCode :: Bool -> Int
+sizeOfEntryCode tables_next_to_code
+  | not tables_next_to_code = 0
   | otherwise =
      case mkJumpToAddr undefined of
        Left  xs -> sizeOf (head xs) * length xs
        Right xs -> sizeOf (head xs) * length xs
 
 -- Note: Must return proper pointer for use in a closure
-newExecConItbl :: StgInfoTable -> [Word8] -> IO (FunPtr ())
-newExecConItbl obj con_desc
+newExecConItbl :: Bool -> StgInfoTable -> [Word8] -> IO (FunPtr ())
+newExecConItbl tables_next_to_code obj con_desc
    = alloca $ \pcode -> do
         let lcon_desc = length con_desc + 1{- null terminator -}
             -- SCARY
             -- This size represents the number of bytes in an StgConInfoTable.
-            sz = fromIntegral (conInfoTableSizeB + sizeOfEntryCode)
+            sz = fromIntegral (conInfoTableSizeB + sizeOfEntryCode tables_next_to_code)
                -- Note: we need to allocate the conDesc string next to the info
                -- table, because on a 64-bit platform we reference this string
                -- with a 32-bit offset relative to the info table, so if we
@@ -358,14 +352,12 @@ newExecConItbl obj con_desc
         ex_ptr <- peek pcode
         let cinfo = StgConInfoTable { conDesc = ex_ptr `plusPtr` fromIntegral sz
                                     , infoTable = obj }
-        pokeConItbl wr_ptr ex_ptr cinfo
+        pokeConItbl tables_next_to_code wr_ptr ex_ptr cinfo
         pokeArray0 0 (castPtr wr_ptr `plusPtr` fromIntegral sz) con_desc
         _flushExec sz ex_ptr -- Cache flush (if needed)
-#if defined(TABLES_NEXT_TO_CODE)
-        return (castPtrToFunPtr (ex_ptr `plusPtr` conInfoTableSizeB))
-#else
-        return (castPtrToFunPtr ex_ptr)
-#endif
+        if tables_next_to_code
+          then return (castPtrToFunPtr (ex_ptr `plusPtr` conInfoTableSizeB))
+          else return (castPtrToFunPtr ex_ptr)
 
 foreign import ccall unsafe "allocateExec"
   _allocateExec :: CUInt -> Ptr (Ptr a) -> IO (Ptr a)
diff --git a/libraries/ghci/GHCi/Message.hs b/libraries/ghci/GHCi/Message.hs
index 7ae1614d0e..9fd38ceaf0 100644
--- a/libraries/ghci/GHCi/Message.hs
+++ b/libraries/ghci/GHCi/Message.hs
@@ -101,7 +101,8 @@ data Message a where
 
   -- | Create an info table for a constructor
   MkConInfoTable
-   :: Int     -- ptr words
+   :: Bool    -- TABLES_NEXT_TO_CODE
+   -> Int     -- ptr words
    -> Int     -- non-ptr words
    -> Int     -- constr tag
    -> Int     -- pointer tag
@@ -437,7 +438,7 @@ getMessage = do
       15 -> Msg <$> MallocStrings <$> get
       16 -> Msg <$> (PrepFFI <$> get <*> get <*> get)
       17 -> Msg <$> FreeFFI <$> get
-      18 -> Msg <$> (MkConInfoTable <$> get <*> get <*> get <*> get <*> get)
+      18 -> Msg <$> (MkConInfoTable <$> get <*> get <*> get <*> get <*> get <*> get)
       19 -> Msg <$> (EvalStmt <$> get <*> get)
       20 -> Msg <$> (ResumeStmt <$> get <*> get)
       21 -> Msg <$> (AbandonStmt <$> get)
@@ -475,7 +476,7 @@ putMessage m = case m of
   MallocStrings bss           -> putWord8 15 >> put bss
   PrepFFI conv args res       -> putWord8 16 >> put conv >> put args >> put res
   FreeFFI p                   -> putWord8 17 >> put p
-  MkConInfoTable p n t pt d   -> putWord8 18 >> put p >> put n >> put t >> put pt >> put d
+  MkConInfoTable tc p n t pt d -> putWord8 18 >> put tc >> put p >> put n >> put t >> put pt >> put d
   EvalStmt opts val           -> putWord8 19 >> put opts >> put val
   ResumeStmt opts val         -> putWord8 20 >> put opts >> put val
   AbandonStmt val             -> putWord8 21 >> put val
diff --git a/libraries/ghci/GHCi/Run.hs b/libraries/ghci/GHCi/Run.hs
index 2988ec202a..48c88fe8e4 100644
--- a/libraries/ghci/GHCi/Run.hs
+++ b/libraries/ghci/GHCi/Run.hs
@@ -83,8 +83,8 @@ run m = case m of
   MallocStrings bss -> mapM mkString0 bss
   PrepFFI conv args res -> toRemotePtr <$> prepForeignCall conv args res
   FreeFFI p -> freeForeignCallInfo (fromRemotePtr p)
-  MkConInfoTable ptrs nptrs tag ptrtag desc ->
-    toRemotePtr <$> mkConInfoTable ptrs nptrs tag ptrtag desc
+  MkConInfoTable tc ptrs nptrs tag ptrtag desc ->
+    toRemotePtr <$> mkConInfoTable tc ptrs nptrs tag ptrtag desc
   StartTH -> startTH
   _other -> error "GHCi.Run.run"
 
-- 
2.23.0


From 715dca20591e3d189742eab80eaf76d448070dbe Mon Sep 17 00:00:00 2001
From: Shao Cheng <cheng.shao@tweag.io>
Date: Thu, 18 Jul 2019 19:14:56 +0800
Subject: [PATCH 06/12] asterius

---
 boot                        |  2 +-
 compiler/cmm/CmmInfo.hs     |  5 +++--
 compiler/ghci/Linker.hs     |  1 +
 compiler/main/Hooks.hs      | 14 ++++++++++++++
 compiler/main/HscMain.hs    |  7 ++++---
 utils/ghc-pkg/ghc-pkg.cabal |  7 +++++++
 utils/hsc2hs                |  2 +-
 7 files changed, 31 insertions(+), 7 deletions(-)

diff --git a/boot b/boot
index d57dcc846b..6d7a315082 100755
--- a/boot
+++ b/boot
@@ -190,7 +190,7 @@ def check_build_mk():
                 http://ghc.haskell.org/trac/ghc/wiki/Building/Using#Buildconfiguration
             """))
 
-check_for_url_rewrites()
+# check_for_url_rewrites()
 if not args.hadrian:
     boot_pkgs()
 autoreconf()
diff --git a/compiler/cmm/CmmInfo.hs b/compiler/cmm/CmmInfo.hs
index 43cba2526d..07798d34c7 100644
--- a/compiler/cmm/CmmInfo.hs
+++ b/compiler/cmm/CmmInfo.hs
@@ -53,6 +53,7 @@ import UniqSupply
 import MonadUtils
 import Util
 import Outputable
+import Module
 
 import Data.Bits
 import Data.Word
@@ -66,9 +67,9 @@ mkEmptyContInfoTable info_lbl
                  , cit_srt  = Nothing
                  , cit_clo  = Nothing }
 
-cmmToRawCmm :: DynFlags -> Stream IO CmmGroup ()
+cmmToRawCmm :: DynFlags -> Maybe Module -> Stream IO CmmGroup ()
             -> IO (Stream IO RawCmmGroup ())
-cmmToRawCmm dflags cmms
+cmmToRawCmm dflags _ cmms
   = do { uniqs <- mkSplitUniqSupply 'i'
        ; let do_one uniqs cmm = do
                 case initUs uniqs $ concatMapM (mkInfoTable dflags) cmm of
diff --git a/compiler/ghci/Linker.hs b/compiler/ghci/Linker.hs
index 3b030be2d3..32cb93eafa 100644
--- a/compiler/ghci/Linker.hs
+++ b/compiler/ghci/Linker.hs
@@ -16,6 +16,7 @@ module Linker ( getHValue, showLinkerState,
                 extendLoadedPkgs,
                 linkPackages,initDynLinker,linkModule,
                 linkCmdLineLibs
+                ,modifyPLS,linkDependencies
         ) where
 
 #include "HsVersions.h"
diff --git a/compiler/main/Hooks.hs b/compiler/main/Hooks.hs
index f9d420ab61..548684b36f 100644
--- a/compiler/main/Hooks.hs
+++ b/compiler/main/Hooks.hs
@@ -21,6 +21,8 @@ module Hooks ( Hooks
              , runRnSpliceHook
              , getValueSafelyHook
              , createIservProcessHook
+             , stgCmmHook
+             , cmmToRawCmmHook
              ) where
 
 import GhcPrelude
@@ -44,6 +46,12 @@ import Type
 import System.Process
 import BasicTypes
 import HsExtension
+import Module
+import TyCon
+import CostCentre
+import StgSyn
+import Stream
+import Cmm
 
 import Data.Maybe
 
@@ -73,6 +81,8 @@ emptyHooks = Hooks
   , runRnSpliceHook        = Nothing
   , getValueSafelyHook     = Nothing
   , createIservProcessHook = Nothing
+  , stgCmmHook             = Nothing
+  , cmmToRawCmmHook        = Nothing
   }
 
 data Hooks = Hooks
@@ -95,6 +105,10 @@ data Hooks = Hooks
   , getValueSafelyHook     :: Maybe (HscEnv -> Name -> Type
                                                           -> IO (Maybe HValue))
   , createIservProcessHook :: Maybe (CreateProcess -> IO ProcessHandle)
+  , stgCmmHook             :: Maybe (DynFlags -> Module -> [TyCon] -> CollectedCCs
+            -> [StgTopBinding] -> HpcInfo -> Stream IO CmmGroup ())
+  , cmmToRawCmmHook        :: Maybe (DynFlags -> Maybe Module -> Stream IO CmmGroup ()
+            -> IO (Stream IO RawCmmGroup ()))
   }
 
 getHooked :: (Functor f, HasDynFlags f) => (Hooks -> Maybe a) -> a -> f a
diff --git a/compiler/main/HscMain.hs b/compiler/main/HscMain.hs
index a8a33bfaad..fbd8adfa2e 100644
--- a/compiler/main/HscMain.hs
+++ b/compiler/main/HscMain.hs
@@ -80,6 +80,7 @@ module HscMain
     , ioMsgMaybe
     , showModuleIndex
     , hscAddSptEntries
+    , doCodeGen
     ) where
 
 import GhcPrelude
@@ -1344,7 +1345,7 @@ hscGenHardCode hsc_env cgguts mod_summary output_filename = do
 
             ------------------  Code output -----------------------
             rawcmms0 <- {-# SCC "cmmToRawCmm" #-}
-                      cmmToRawCmm dflags cmms
+                      lookupHook cmmToRawCmmHook cmmToRawCmm dflags dflags (Just this_mod) cmms
 
             let dump a = do dumpIfSet_dyn dflags Opt_D_dump_cmm_raw "Raw Cmm"
                               (ppr a)
@@ -1403,7 +1404,7 @@ hscCompileCmmFile hsc_env filename output_filename = runHsc hsc_env $ do
             mod_name = mkModuleName $ "Cmm$" ++ FilePath.takeFileName filename
             cmm_mod = mkModule (thisPackage dflags) mod_name
         (_, cmmgroup) <- cmmPipeline hsc_env (emptySRT cmm_mod) cmm
-        rawCmms <- cmmToRawCmm dflags (Stream.yield cmmgroup)
+        rawCmms <- lookupHook cmmToRawCmmHook cmmToRawCmm dflags dflags Nothing (Stream.yield cmmgroup)
         _ <- codeOutput dflags cmm_mod output_filename no_loc NoStubs [] []
              rawCmms
         return ()
@@ -1428,7 +1429,7 @@ doCodeGen hsc_env this_mod data_tycons
 
     let cmm_stream :: Stream IO CmmGroup ()
         cmm_stream = {-# SCC "StgCmm" #-}
-            StgCmm.codeGen dflags this_mod data_tycons
+            lookupHook stgCmmHook StgCmm.codeGen dflags dflags this_mod data_tycons
                            cost_centre_info stg_binds hpc_info
 
         -- codegen consumes a stream of CmmGroup, and produces a new
diff --git a/utils/ghc-pkg/ghc-pkg.cabal b/utils/ghc-pkg/ghc-pkg.cabal
index 4b1aae7631..3f4c6ed137 100644
--- a/utils/ghc-pkg/ghc-pkg.cabal
+++ b/utils/ghc-pkg/ghc-pkg.cabal
@@ -15,6 +15,11 @@ Category: Development
 build-type: Simple
 cabal-version: >=1.10
 
+Flag threaded
+    Description: Link the ghc-pkg executable against the threaded RTS
+    Default: True
+    Manual: True
+
 Flag terminfo
     Description: Build GHC with terminfo support on non-Windows platforms.
     Default: True
@@ -35,6 +40,8 @@ Executable ghc-pkg
                    binary,
                    ghc-boot,
                    bytestring
+    if flag(threaded)
+        ghc-options: -threaded
     if !os(windows) && flag(terminfo)
         Build-Depends: terminfo
         Cpp-Options: -DWITH_TERMINFO
diff --git a/utils/hsc2hs b/utils/hsc2hs
index 0212778440..fe41381767 160000
--- a/utils/hsc2hs
+++ b/utils/hsc2hs
@@ -1 +1 @@
-Subproject commit 0212778440cc83dabc3f1206fe04a3b934faf152
+Subproject commit fe41381767628ad42cf54840670aeae5083e77db
-- 
2.23.0


From f8fb851471a46c75806da09c635724f06416ff4e Mon Sep 17 00:00:00 2001
From: Shao Cheng <cheng.shao@tweag.io>
Date: Mon, 26 Aug 2019 16:31:29 +0800
Subject: [PATCH 07/12] asterius iserv

---
 compiler/ghci/GHCi.hs          | 27 +++++++++++++++++++--------
 compiler/main/Hooks.hs         | 12 ++++++++++++
 compiler/typecheck/TcSplice.hs |  2 +-
 3 files changed, 32 insertions(+), 9 deletions(-)

diff --git a/compiler/ghci/GHCi.hs b/compiler/ghci/GHCi.hs
index 472f0857cb..f0659f1e45 100644
--- a/compiler/ghci/GHCi.hs
+++ b/compiler/ghci/GHCi.hs
@@ -170,7 +170,7 @@ iservCmd hsc_env@HscEnv{..} msg
  | gopt Opt_ExternalInterpreter hsc_dflags =
      withIServ hsc_env $ \iserv ->
        uninterruptibleMask_ $ do -- Note [uninterruptibleMask_]
-         iservCall iserv msg
+         iservCall hsc_dflags iserv msg
  | otherwise = -- Just run it directly
 #if defined(GHCI)
    run msg
@@ -202,7 +202,7 @@ withIServ HscEnv{..} action =
     let iserv' = iserv{ iservPendingFrees = [] }
     a <- (do
       liftIO $ when (not (null (iservPendingFrees iserv))) $
-        iservCall iserv (FreeHValueRefs (iservPendingFrees iserv))
+        iservCall hsc_dflags iserv (FreeHValueRefs (iservPendingFrees iserv))
         -- run the inner action
       restore $ action iserv)
           `gonException` (liftIO $ putMVar hsc_iserv (Just iserv'))
@@ -369,7 +369,7 @@ lookupSymbol hsc_env@HscEnv{..} str
          Just p -> return (Just p)
          Nothing -> do
            m <- uninterruptibleMask_ $
-                    iservCall iserv (LookupSymbol (unpackFS str))
+                    iservCall hsc_dflags iserv (LookupSymbol (unpackFS str))
            case m of
              Nothing -> return Nothing
              Just r -> do
@@ -446,8 +446,11 @@ findSystemLibrary hsc_env str = iservCmd hsc_env (FindSystemLibrary str)
 -- Raw calls and messages
 
 -- | Send a 'Message' and receive the response from the iserv process
-iservCall :: Binary a => IServ -> Message a -> IO a
-iservCall iserv@IServ{..} msg =
+iservCall :: Binary a => DynFlags -> IServ -> Message a -> IO a
+iservCall dflags = lookupHook iservCallHook (iservCall' dflags) dflags
+
+iservCall' :: Binary a => DynFlags -> IServ -> Message a -> IO a
+iservCall' _ iserv@IServ{..} msg =
   remoteCall iservPipe msg
     `catch` \(e :: SomeException) -> handleIServFailure iserv e
 
@@ -478,7 +481,11 @@ handleIServFailure IServ{..} e = do
 -- Starting and stopping the iserv process
 
 startIServ :: DynFlags -> IO IServ
-startIServ dflags = do
+startIServ dflags =
+  maybe (startIServ' dflags) ($ dflags) (startIServHook (hooks dflags))
+
+startIServ' :: DynFlags -> IO IServ
+startIServ' dflags = do
   let flavour
         | WayProf `elem` ways dflags = "-prof"
         | WayDyn `elem` ways dflags = "-dyn"
@@ -503,7 +510,11 @@ startIServ dflags = do
     }
 
 stopIServ :: HscEnv -> IO ()
-stopIServ HscEnv{..} =
+stopIServ hsc_env@HscEnv {..} =
+  maybe (stopIServ' hsc_env) ($ hsc_env) (stopIServHook (hooks hsc_dflags))
+
+stopIServ' :: HscEnv -> IO ()
+stopIServ' HscEnv{..} =
   gmask $ \_restore -> do
     m <- takeMVar hsc_iserv
     maybe (return ()) stop m
@@ -513,7 +524,7 @@ stopIServ HscEnv{..} =
     ex <- getProcessExitCode (iservProcess iserv)
     if isJust ex
        then return ()
-       else iservCall iserv Shutdown
+       else iservCall hsc_dflags iserv Shutdown
 
 runWithPipes :: (CreateProcess -> IO ProcessHandle)
              -> FilePath -> [String] -> IO (ProcessHandle, Handle, Handle)
diff --git a/compiler/main/Hooks.hs b/compiler/main/Hooks.hs
index 548684b36f..1cd69a50a0 100644
--- a/compiler/main/Hooks.hs
+++ b/compiler/main/Hooks.hs
@@ -4,6 +4,7 @@
 --     refer to *types*, rather than *code*
 
 {-# LANGUAGE CPP #-}
+{-# LANGUAGE RankNTypes #-}
 module Hooks ( Hooks
              , emptyHooks
              , lookupHook
@@ -23,6 +24,9 @@ module Hooks ( Hooks
              , createIservProcessHook
              , stgCmmHook
              , cmmToRawCmmHook
+             , startIServHook
+             , iservCallHook
+             , stopIServHook
              ) where
 
 import GhcPrelude
@@ -52,7 +56,9 @@ import CostCentre
 import StgSyn
 import Stream
 import Cmm
+import GHCi.Message
 
+import Data.Binary
 import Data.Maybe
 
 {-
@@ -83,6 +89,9 @@ emptyHooks = Hooks
   , createIservProcessHook = Nothing
   , stgCmmHook             = Nothing
   , cmmToRawCmmHook        = Nothing
+  , startIServHook         = Nothing
+  , iservCallHook          = Nothing
+  , stopIServHook          = Nothing
   }
 
 data Hooks = Hooks
@@ -109,6 +118,9 @@ data Hooks = Hooks
             -> [StgTopBinding] -> HpcInfo -> Stream IO CmmGroup ())
   , cmmToRawCmmHook        :: Maybe (DynFlags -> Maybe Module -> Stream IO CmmGroup ()
             -> IO (Stream IO RawCmmGroup ()))
+  , startIServHook         :: Maybe (DynFlags -> IO IServ)
+  , iservCallHook          :: forall a . Binary a => Maybe (IServ -> Message a -> IO a)
+  , stopIServHook          :: Maybe (HscEnv -> IO ())
   }
 
 getHooked :: (Functor f, HasDynFlags f) => (Hooks -> Maybe a) -> a -> f a
diff --git a/compiler/typecheck/TcSplice.hs b/compiler/typecheck/TcSplice.hs
index 737ddccfbd..1ee9e427b7 100644
--- a/compiler/typecheck/TcSplice.hs
+++ b/compiler/typecheck/TcSplice.hs
@@ -1113,7 +1113,7 @@ getTHState i = do
     Just rhv -> return rhv
     Nothing -> do
       hsc_env <- env_top <$> getEnv
-      fhv <- liftIO $ mkFinalizedHValue hsc_env =<< iservCall i StartTH
+      fhv <- liftIO $ mkFinalizedHValue hsc_env =<< iservCall (hsc_dflags hsc_env) i StartTH
       writeTcRef (tcg_th_remote_state tcg) (Just fhv)
       return fhv
 
-- 
2.23.0


From 6b444680c1af15ae90d1f65f6631727e14b07670 Mon Sep 17 00:00:00 2001
From: Shao Cheng <cheng.shao@tweag.io>
Date: Wed, 28 Aug 2019 08:24:29 +0800
Subject: [PATCH 08/12] asterius iserv

---
 compiler/ghci/GHCi.hs          | 85 ++++++++++++++++++++++++++++++----
 compiler/main/Hooks.hs         |  7 +++
 compiler/typecheck/TcSplice.hs | 33 ++++++-------
 libraries/ghci/GHCi/Message.hs |  4 +-
 4 files changed, 103 insertions(+), 26 deletions(-)

diff --git a/compiler/ghci/GHCi.hs b/compiler/ghci/GHCi.hs
index f0659f1e45..5e7a7311a8 100644
--- a/compiler/ghci/GHCi.hs
+++ b/compiler/ghci/GHCi.hs
@@ -1,4 +1,6 @@
 {-# LANGUAGE RecordWildCards, ScopedTypeVariables, BangPatterns, CPP #-}
+{-# LANGUAGE GADTs #-}
+{-# LANGUAGE TypeApplications #-}
 
 --
 -- | Interacting with the interpreter, whether it is running on an
@@ -90,6 +92,9 @@ import System.Posix as Posix
 import System.Directory
 import System.Process
 import GHC.Conc (getNumProcessors, pseq, par)
+import qualified Language.Haskell.TH.Syntax as TH
+import GHC.LanguageExtensions.Type
+import Type.Reflection
 
 {- Note [Remote GHCi]
 
@@ -455,16 +460,80 @@ iservCall' _ iserv@IServ{..} msg =
     `catch` \(e :: SomeException) -> handleIServFailure iserv e
 
 -- | Read a value from the iserv process
-readIServ :: IServ -> Get a -> IO a
-readIServ iserv@IServ{..} get =
-  readPipe iservPipe get
-    `catch` \(e :: SomeException) -> handleIServFailure iserv e
+readIServ :: forall a. Typeable a => DynFlags -> IServ -> IO a
+readIServ dflags = lookupHook readIServHook readIServ' dflags dflags
+
+readIServ' :: forall a. Typeable a => DynFlags -> IServ -> IO a
+readIServ' _ iserv@IServ {..}
+  | Just HRefl <- eqTypeRep (typeRep @a) (typeRep @THMsg) =
+    readPipe iservPipe getTHMessage
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeRep @a) (typeRep @(QResult ByteString)) =
+    readPipe iservPipe get
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeRep @a) (typeRep @(QResult ())) =
+    readPipe iservPipe get
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | otherwise = handleIServFailure iserv $ toException $ userError $ "readIServ: unsupported type " ++ show (typeRep @a)
 
 -- | Send a value to the iserv process
-writeIServ :: IServ -> Put -> IO ()
-writeIServ iserv@IServ{..} put =
-  writePipe iservPipe put
-    `catch` \(e :: SomeException) -> handleIServFailure iserv e
+writeIServ :: Typeable a => DynFlags -> IServ -> a -> IO ()
+writeIServ dflags = lookupHook writeIServHook writeIServ' dflags dflags
+
+writeIServ' :: Typeable a => DynFlags -> IServ -> a -> IO ()
+writeIServ' _ iserv@IServ {..} a
+  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(Message (QResult ByteString))) =
+    writePipe iservPipe (putMessage a)
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(Message (QResult ()))) =
+    writePipe iservPipe (putMessage a)
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult TH.Name)) =
+    writePipe iservPipe (put a)
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult ())) =
+    writePipe iservPipe (put a)
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult (Maybe TH.Name))) =
+    writePipe iservPipe (put a)
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult TH.Info)) =
+    writePipe iservPipe (put a)
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult (Maybe TH.Fixity))) =
+    writePipe iservPipe (put a)
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult [TH.Dec])) =
+    writePipe iservPipe (put a)
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult [TH.Role])) =
+    writePipe iservPipe (put a)
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult [ByteString])) =
+    writePipe iservPipe (put a)
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult TH.ModuleInfo)) =
+    writePipe iservPipe (put a)
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult [TH.DecidedStrictness])) =
+    writePipe iservPipe (put a)
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult FilePath)) =
+    writePipe iservPipe (put a)
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult Bool)) =
+    writePipe iservPipe (put a)
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult [Extension])) =
+    writePipe iservPipe (put a)
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult [Extension])) =
+    writePipe iservPipe (put a)
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @()) =
+    writePipe iservPipe (put a)
+      `catch` \(e :: SomeException) -> handleIServFailure iserv e
+  | otherwise = handleIServFailure iserv $ toException $ userError $ "writeIServ: unsupported type " ++ show (typeOf a)
 
 handleIServFailure :: IServ -> SomeException -> IO a
 handleIServFailure IServ{..} e = do
diff --git a/compiler/main/Hooks.hs b/compiler/main/Hooks.hs
index 1cd69a50a0..7935356a43 100644
--- a/compiler/main/Hooks.hs
+++ b/compiler/main/Hooks.hs
@@ -26,6 +26,8 @@ module Hooks ( Hooks
              , cmmToRawCmmHook
              , startIServHook
              , iservCallHook
+             , readIServHook
+             , writeIServHook
              , stopIServHook
              ) where
 
@@ -60,6 +62,7 @@ import GHCi.Message
 
 import Data.Binary
 import Data.Maybe
+import Type.Reflection (Typeable)
 
 {-
 ************************************************************************
@@ -91,6 +94,8 @@ emptyHooks = Hooks
   , cmmToRawCmmHook        = Nothing
   , startIServHook         = Nothing
   , iservCallHook          = Nothing
+  , readIServHook          = Nothing
+  , writeIServHook         = Nothing
   , stopIServHook          = Nothing
   }
 
@@ -120,6 +125,8 @@ data Hooks = Hooks
             -> IO (Stream IO RawCmmGroup ()))
   , startIServHook         :: Maybe (DynFlags -> IO IServ)
   , iservCallHook          :: forall a . Binary a => Maybe (IServ -> Message a -> IO a)
+  , readIServHook          :: forall a . Typeable a => Maybe (DynFlags -> IServ -> IO a)
+  , writeIServHook         :: forall a . Typeable a => Maybe (DynFlags -> IServ -> a -> IO ())
   , stopIServHook          :: Maybe (HscEnv -> IO ())
   }
 
diff --git a/compiler/typecheck/TcSplice.hs b/compiler/typecheck/TcSplice.hs
index 1ee9e427b7..0b2427af31 100644
--- a/compiler/typecheck/TcSplice.hs
+++ b/compiler/typecheck/TcSplice.hs
@@ -651,9 +651,9 @@ runRemoteModFinalizers (ThModFinalizers finRefs) = do
         Just fhv -> do
           liftIO $ withForeignRef fhv $ \st ->
             withForeignRefs finRefs $ \qrefs ->
-              writeIServ i (putMessage (RunModFinalizers st qrefs))
-          () <- runRemoteTH i []
-          readQResult i
+              writeIServ (hsc_dflags hsc_env) i (RunModFinalizers st qrefs)
+          () <- runRemoteTH (hsc_dflags hsc_env) i []
+          readQResult (hsc_dflags hsc_env) i
   else do
     qs <- liftIO (withForeignRefs finRefs $ mapM localRef)
     runQuasi $ sequence_ qs
@@ -1018,27 +1018,28 @@ runTH ty fhv = do
         liftIO $
           withForeignRef rstate $ \state_hv ->
           withForeignRef fhv $ \q_hv ->
-            writeIServ i (putMessage (RunTH state_hv q_hv ty (Just loc)))
-        runRemoteTH i []
-        bs <- readQResult i
+            writeIServ (hsc_dflags hsc_env) i (RunTH state_hv q_hv ty (Just loc))
+        runRemoteTH (hsc_dflags hsc_env) i []
+        bs <- readQResult (hsc_dflags hsc_env) i
         return $! runGet get (LB.fromStrict bs)
 
 
 -- | communicate with a remotely-running TH computation until it finishes.
 -- See Note [Remote Template Haskell] in libraries/ghci/GHCi/TH.hs.
 runRemoteTH
-  :: IServ
+  :: DynFlags
+  -> IServ
   -> [Messages]   --  saved from nested calls to qRecover
   -> TcM ()
-runRemoteTH iserv recovers = do
-  THMsg msg <- liftIO $ readIServ iserv getTHMessage
+runRemoteTH dflags iserv recovers = do
+  THMsg msg <- liftIO $ readIServ dflags iserv
   case msg of
     RunTHDone -> return ()
     StartRecover -> do -- Note [TH recover with -fexternal-interpreter]
       v <- getErrsVar
       msgs <- readTcRef v
       writeTcRef v emptyMessages
-      runRemoteTH iserv (msgs : recovers)
+      runRemoteTH dflags iserv (msgs : recovers)
     EndRecover caught_error -> do
       let (prev_msgs@(prev_warns,prev_errs), rest) = case recovers of
              [] -> panic "EndRecover"
@@ -1049,16 +1050,16 @@ runRemoteTH iserv recovers = do
       writeTcRef v $ if caught_error
         then prev_msgs
         else (prev_warns `unionBags` warn_msgs, prev_errs)
-      runRemoteTH iserv rest
+      runRemoteTH dflags iserv rest
     _other -> do
       r <- handleTHMessage msg
-      liftIO $ writeIServ iserv (put r)
-      runRemoteTH iserv recovers
+      liftIO $ writeIServ dflags iserv r
+      runRemoteTH dflags iserv recovers
 
 -- | Read a value of type QResult from the iserv
-readQResult :: Binary a => IServ -> TcM a
-readQResult i = do
-  qr <- liftIO $ readIServ i get
+readQResult :: (Binary a, Typeable a) => DynFlags -> IServ -> TcM a
+readQResult dflags i = do
+  qr <- liftIO $ readIServ dflags i
   case qr of
     QDone a -> return a
     QException str -> liftIO $ throwIO (ErrorCall str)
diff --git a/libraries/ghci/GHCi/Message.hs b/libraries/ghci/GHCi/Message.hs
index 9fd38ceaf0..ef03104051 100644
--- a/libraries/ghci/GHCi/Message.hs
+++ b/libraries/ghci/GHCi/Message.hs
@@ -40,7 +40,7 @@ import Data.ByteString (ByteString)
 import qualified Data.ByteString as B
 import qualified Data.ByteString.Lazy as LB
 import Data.Dynamic
-import Data.Typeable (TypeRep)
+import Data.Typeable (Typeable, TypeRep)
 import Data.IORef
 import Data.Map (Map)
 import GHC.Generics
@@ -254,7 +254,7 @@ data THMessage a where
 
 deriving instance Show (THMessage a)
 
-data THMsg = forall a . (Binary a, Show a) => THMsg (THMessage a)
+data THMsg = forall a . (Binary a, Show a, Typeable a) => THMsg (THMessage a)
 
 getTHMessage :: Get THMsg
 getTHMessage = do
-- 
2.23.0


From 5bea811438d940b370bc85a89d888eeee4b71c6d Mon Sep 17 00:00:00 2001
From: Shao Cheng <cheng.shao@tweag.io>
Date: Wed, 4 Sep 2019 10:44:23 +0800
Subject: [PATCH 09/12] asterius iserv

---
 compiler/ghci/GHCi.hs          | 45 +++++++++++++++++-----------------
 compiler/main/Hooks.hs         |  8 +++---
 compiler/typecheck/TcSplice.hs | 34 ++++++++++++-------------
 3 files changed, 44 insertions(+), 43 deletions(-)

diff --git a/compiler/ghci/GHCi.hs b/compiler/ghci/GHCi.hs
index 5e7a7311a8..7baa518fd2 100644
--- a/compiler/ghci/GHCi.hs
+++ b/compiler/ghci/GHCi.hs
@@ -175,7 +175,7 @@ iservCmd hsc_env@HscEnv{..} msg
  | gopt Opt_ExternalInterpreter hsc_dflags =
      withIServ hsc_env $ \iserv ->
        uninterruptibleMask_ $ do -- Note [uninterruptibleMask_]
-         iservCall hsc_dflags iserv msg
+         iservCall hsc_env iserv msg
  | otherwise = -- Just run it directly
 #if defined(GHCI)
    run msg
@@ -197,17 +197,17 @@ iservCmd hsc_env@HscEnv{..} msg
 withIServ
   :: (MonadIO m, ExceptionMonad m)
   => HscEnv -> (IServ -> m a) -> m a
-withIServ HscEnv{..} action =
+withIServ hsc_env@HscEnv{..} action =
   gmask $ \restore -> do
     m <- liftIO $ takeMVar hsc_iserv
       -- start the iserv process if we haven't done so yet
-    iserv <- maybe (liftIO $ startIServ hsc_dflags) return m
+    iserv <- maybe (liftIO $ startIServ hsc_env) return m
                `gonException` (liftIO $ putMVar hsc_iserv Nothing)
       -- free any ForeignHValues that have been garbage collected.
     let iserv' = iserv{ iservPendingFrees = [] }
     a <- (do
       liftIO $ when (not (null (iservPendingFrees iserv))) $
-        iservCall hsc_dflags iserv (FreeHValueRefs (iservPendingFrees iserv))
+        iservCall hsc_env iserv (FreeHValueRefs (iservPendingFrees iserv))
         -- run the inner action
       restore $ action iserv)
           `gonException` (liftIO $ putMVar hsc_iserv (Just iserv'))
@@ -374,7 +374,7 @@ lookupSymbol hsc_env@HscEnv{..} str
          Just p -> return (Just p)
          Nothing -> do
            m <- uninterruptibleMask_ $
-                    iservCall hsc_dflags iserv (LookupSymbol (unpackFS str))
+                    iservCall hsc_env iserv (LookupSymbol (unpackFS str))
            case m of
              Nothing -> return Nothing
              Just r -> do
@@ -451,19 +451,19 @@ findSystemLibrary hsc_env str = iservCmd hsc_env (FindSystemLibrary str)
 -- Raw calls and messages
 
 -- | Send a 'Message' and receive the response from the iserv process
-iservCall :: Binary a => DynFlags -> IServ -> Message a -> IO a
-iservCall dflags = lookupHook iservCallHook (iservCall' dflags) dflags
+iservCall :: Binary a => HscEnv -> IServ -> Message a -> IO a
+iservCall hsc_env = lookupHook iservCallHook iservCall' (hsc_dflags hsc_env) hsc_env
 
-iservCall' :: Binary a => DynFlags -> IServ -> Message a -> IO a
+iservCall' :: Binary a => HscEnv -> IServ -> Message a -> IO a
 iservCall' _ iserv@IServ{..} msg =
   remoteCall iservPipe msg
     `catch` \(e :: SomeException) -> handleIServFailure iserv e
 
 -- | Read a value from the iserv process
-readIServ :: forall a. Typeable a => DynFlags -> IServ -> IO a
-readIServ dflags = lookupHook readIServHook readIServ' dflags dflags
+readIServ :: forall a. Typeable a => HscEnv -> IServ -> IO a
+readIServ hsc_env = lookupHook readIServHook readIServ' (hsc_dflags hsc_env) hsc_env
 
-readIServ' :: forall a. Typeable a => DynFlags -> IServ -> IO a
+readIServ' :: forall a. Typeable a => HscEnv -> IServ -> IO a
 readIServ' _ iserv@IServ {..}
   | Just HRefl <- eqTypeRep (typeRep @a) (typeRep @THMsg) =
     readPipe iservPipe getTHMessage
@@ -477,10 +477,10 @@ readIServ' _ iserv@IServ {..}
   | otherwise = handleIServFailure iserv $ toException $ userError $ "readIServ: unsupported type " ++ show (typeRep @a)
 
 -- | Send a value to the iserv process
-writeIServ :: Typeable a => DynFlags -> IServ -> a -> IO ()
-writeIServ dflags = lookupHook writeIServHook writeIServ' dflags dflags
+writeIServ :: Typeable a => HscEnv -> IServ -> a -> IO ()
+writeIServ hsc_env = lookupHook writeIServHook writeIServ' (hsc_dflags hsc_env) hsc_env
 
-writeIServ' :: Typeable a => DynFlags -> IServ -> a -> IO ()
+writeIServ' :: Typeable a => HscEnv -> IServ -> a -> IO ()
 writeIServ' _ iserv@IServ {..} a
   | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(Message (QResult ByteString))) =
     writePipe iservPipe (putMessage a)
@@ -549,13 +549,14 @@ handleIServFailure IServ{..} e = do
 -- -----------------------------------------------------------------------------
 -- Starting and stopping the iserv process
 
-startIServ :: DynFlags -> IO IServ
-startIServ dflags =
-  maybe (startIServ' dflags) ($ dflags) (startIServHook (hooks dflags))
+startIServ :: HscEnv -> IO IServ
+startIServ hsc_env =
+  maybe (startIServ' hsc_env) ($ hsc_env) (startIServHook (hooks (hsc_dflags hsc_env)))
 
-startIServ' :: DynFlags -> IO IServ
-startIServ' dflags = do
-  let flavour
+startIServ' :: HscEnv -> IO IServ
+startIServ' hsc_env = do
+  let dflags = hsc_dflags hsc_env
+      flavour
         | WayProf `elem` ways dflags = "-prof"
         | WayDyn `elem` ways dflags = "-dyn"
         | otherwise = ""
@@ -583,7 +584,7 @@ stopIServ hsc_env@HscEnv {..} =
   maybe (stopIServ' hsc_env) ($ hsc_env) (stopIServHook (hooks hsc_dflags))
 
 stopIServ' :: HscEnv -> IO ()
-stopIServ' HscEnv{..} =
+stopIServ' hsc_env@HscEnv{..} =
   gmask $ \_restore -> do
     m <- takeMVar hsc_iserv
     maybe (return ()) stop m
@@ -593,7 +594,7 @@ stopIServ' HscEnv{..} =
     ex <- getProcessExitCode (iservProcess iserv)
     if isJust ex
        then return ()
-       else iservCall hsc_dflags iserv Shutdown
+       else iservCall hsc_env iserv Shutdown
 
 runWithPipes :: (CreateProcess -> IO ProcessHandle)
              -> FilePath -> [String] -> IO (ProcessHandle, Handle, Handle)
diff --git a/compiler/main/Hooks.hs b/compiler/main/Hooks.hs
index 7935356a43..c967f13e60 100644
--- a/compiler/main/Hooks.hs
+++ b/compiler/main/Hooks.hs
@@ -123,10 +123,10 @@ data Hooks = Hooks
             -> [StgTopBinding] -> HpcInfo -> Stream IO CmmGroup ())
   , cmmToRawCmmHook        :: Maybe (DynFlags -> Maybe Module -> Stream IO CmmGroup ()
             -> IO (Stream IO RawCmmGroup ()))
-  , startIServHook         :: Maybe (DynFlags -> IO IServ)
-  , iservCallHook          :: forall a . Binary a => Maybe (IServ -> Message a -> IO a)
-  , readIServHook          :: forall a . Typeable a => Maybe (DynFlags -> IServ -> IO a)
-  , writeIServHook         :: forall a . Typeable a => Maybe (DynFlags -> IServ -> a -> IO ())
+  , startIServHook         :: Maybe (HscEnv -> IO IServ)
+  , iservCallHook          :: forall a . Binary a => Maybe (HscEnv -> IServ -> Message a -> IO a)
+  , readIServHook          :: forall a . Typeable a => Maybe (HscEnv -> IServ -> IO a)
+  , writeIServHook         :: forall a . Typeable a => Maybe (HscEnv -> IServ -> a -> IO ())
   , stopIServHook          :: Maybe (HscEnv -> IO ())
   }
 
diff --git a/compiler/typecheck/TcSplice.hs b/compiler/typecheck/TcSplice.hs
index 0b2427af31..e35fd0bead 100644
--- a/compiler/typecheck/TcSplice.hs
+++ b/compiler/typecheck/TcSplice.hs
@@ -651,9 +651,9 @@ runRemoteModFinalizers (ThModFinalizers finRefs) = do
         Just fhv -> do
           liftIO $ withForeignRef fhv $ \st ->
             withForeignRefs finRefs $ \qrefs ->
-              writeIServ (hsc_dflags hsc_env) i (RunModFinalizers st qrefs)
-          () <- runRemoteTH (hsc_dflags hsc_env) i []
-          readQResult (hsc_dflags hsc_env) i
+              writeIServ hsc_env i (RunModFinalizers st qrefs)
+          () <- runRemoteTH hsc_env i []
+          readQResult hsc_env i
   else do
     qs <- liftIO (withForeignRefs finRefs $ mapM localRef)
     runQuasi $ sequence_ qs
@@ -1018,28 +1018,28 @@ runTH ty fhv = do
         liftIO $
           withForeignRef rstate $ \state_hv ->
           withForeignRef fhv $ \q_hv ->
-            writeIServ (hsc_dflags hsc_env) i (RunTH state_hv q_hv ty (Just loc))
-        runRemoteTH (hsc_dflags hsc_env) i []
-        bs <- readQResult (hsc_dflags hsc_env) i
+            writeIServ hsc_env i (RunTH state_hv q_hv ty (Just loc))
+        runRemoteTH hsc_env i []
+        bs <- readQResult hsc_env i
         return $! runGet get (LB.fromStrict bs)
 
 
 -- | communicate with a remotely-running TH computation until it finishes.
 -- See Note [Remote Template Haskell] in libraries/ghci/GHCi/TH.hs.
 runRemoteTH
-  :: DynFlags
+  :: HscEnv
   -> IServ
   -> [Messages]   --  saved from nested calls to qRecover
   -> TcM ()
-runRemoteTH dflags iserv recovers = do
-  THMsg msg <- liftIO $ readIServ dflags iserv
+runRemoteTH hsc_env iserv recovers = do
+  THMsg msg <- liftIO $ readIServ hsc_env iserv
   case msg of
     RunTHDone -> return ()
     StartRecover -> do -- Note [TH recover with -fexternal-interpreter]
       v <- getErrsVar
       msgs <- readTcRef v
       writeTcRef v emptyMessages
-      runRemoteTH dflags iserv (msgs : recovers)
+      runRemoteTH hsc_env iserv (msgs : recovers)
     EndRecover caught_error -> do
       let (prev_msgs@(prev_warns,prev_errs), rest) = case recovers of
              [] -> panic "EndRecover"
@@ -1050,16 +1050,16 @@ runRemoteTH dflags iserv recovers = do
       writeTcRef v $ if caught_error
         then prev_msgs
         else (prev_warns `unionBags` warn_msgs, prev_errs)
-      runRemoteTH dflags iserv rest
+      runRemoteTH hsc_env iserv rest
     _other -> do
       r <- handleTHMessage msg
-      liftIO $ writeIServ dflags iserv r
-      runRemoteTH dflags iserv recovers
+      liftIO $ writeIServ hsc_env iserv r
+      runRemoteTH hsc_env iserv recovers
 
 -- | Read a value of type QResult from the iserv
-readQResult :: (Binary a, Typeable a) => DynFlags -> IServ -> TcM a
-readQResult dflags i = do
-  qr <- liftIO $ readIServ dflags i
+readQResult :: (Binary a, Typeable a) => HscEnv -> IServ -> TcM a
+readQResult hsc_env i = do
+  qr <- liftIO $ readIServ hsc_env i
   case qr of
     QDone a -> return a
     QException str -> liftIO $ throwIO (ErrorCall str)
@@ -1114,7 +1114,7 @@ getTHState i = do
     Just rhv -> return rhv
     Nothing -> do
       hsc_env <- env_top <$> getEnv
-      fhv <- liftIO $ mkFinalizedHValue hsc_env =<< iservCall (hsc_dflags hsc_env) i StartTH
+      fhv <- liftIO $ mkFinalizedHValue hsc_env =<< iservCall hsc_env i StartTH
       writeTcRef (tcg_th_remote_state tcg) (Just fhv)
       return fhv
 
-- 
2.23.0


From ddc2f581b55977aeea221c37c50e155d02f8957f Mon Sep 17 00:00:00 2001
From: Shao Cheng <cheng.shao@tweag.io>
Date: Fri, 13 Sep 2019 22:23:38 +0800
Subject: [PATCH 10/12] asterius iserv

---
 compiler/ghci/GHCi.hs | 1 +
 1 file changed, 1 insertion(+)

diff --git a/compiler/ghci/GHCi.hs b/compiler/ghci/GHCi.hs
index 7baa518fd2..1b06906d8e 100644
--- a/compiler/ghci/GHCi.hs
+++ b/compiler/ghci/GHCi.hs
@@ -40,6 +40,7 @@ module GHCi
   -- * Lower-level API using messages
   , iservCmd, Message(..), withIServ, stopIServ
   , iservCall, readIServ, writeIServ
+  , iservCall', readIServ', writeIServ'
   , purgeLookupSymbolCache
   , freeHValueRefs
   , mkFinalizedHValue
-- 
2.23.0


From 5cc146c20927fbf9c1d85aff4223b9e519aa75c9 Mon Sep 17 00:00:00 2001
From: Shao Cheng <cheng.shao@tweag.io>
Date: Sun, 15 Sep 2019 02:22:01 +0800
Subject: [PATCH 11/12] asterius iserv

---
 compiler/ghci/GHCi.hs          | 14 +++++++-------
 compiler/main/Hooks.hs         |  6 +++---
 compiler/typecheck/TcSplice.hs |  4 ++--
 libraries/ghci/GHCi/Message.hs |  9 ++++++++-
 4 files changed, 20 insertions(+), 13 deletions(-)

diff --git a/compiler/ghci/GHCi.hs b/compiler/ghci/GHCi.hs
index 1b06906d8e..1942c86dd8 100644
--- a/compiler/ghci/GHCi.hs
+++ b/compiler/ghci/GHCi.hs
@@ -171,7 +171,7 @@ needExtInt = throwIO
 -- external iserv process, and the response is deserialized (hence the
 -- @Binary@ constraint).  With @-fno-external-interpreter@ we execute
 -- the command directly here.
-iservCmd :: Binary a => HscEnv -> Message a -> IO a
+iservCmd :: (Binary a, Typeable a) => HscEnv -> Message a -> IO a
 iservCmd hsc_env@HscEnv{..} msg
  | gopt Opt_ExternalInterpreter hsc_dflags =
      withIServ hsc_env $ \iserv ->
@@ -452,19 +452,19 @@ findSystemLibrary hsc_env str = iservCmd hsc_env (FindSystemLibrary str)
 -- Raw calls and messages
 
 -- | Send a 'Message' and receive the response from the iserv process
-iservCall :: Binary a => HscEnv -> IServ -> Message a -> IO a
+iservCall :: (Binary a, Typeable a) => HscEnv -> IServ -> Message a -> IO a
 iservCall hsc_env = lookupHook iservCallHook iservCall' (hsc_dflags hsc_env) hsc_env
 
-iservCall' :: Binary a => HscEnv -> IServ -> Message a -> IO a
+iservCall' :: (Binary a, Typeable a) => HscEnv -> IServ -> Message a -> IO a
 iservCall' _ iserv@IServ{..} msg =
   remoteCall iservPipe msg
     `catch` \(e :: SomeException) -> handleIServFailure iserv e
 
 -- | Read a value from the iserv process
-readIServ :: forall a. Typeable a => HscEnv -> IServ -> IO a
+readIServ :: forall a. (Binary a, Typeable a) => HscEnv -> IServ -> IO a
 readIServ hsc_env = lookupHook readIServHook readIServ' (hsc_dflags hsc_env) hsc_env
 
-readIServ' :: forall a. Typeable a => HscEnv -> IServ -> IO a
+readIServ' :: forall a. (Binary a, Typeable a) => HscEnv -> IServ -> IO a
 readIServ' _ iserv@IServ {..}
   | Just HRefl <- eqTypeRep (typeRep @a) (typeRep @THMsg) =
     readPipe iservPipe getTHMessage
@@ -478,10 +478,10 @@ readIServ' _ iserv@IServ {..}
   | otherwise = handleIServFailure iserv $ toException $ userError $ "readIServ: unsupported type " ++ show (typeRep @a)
 
 -- | Send a value to the iserv process
-writeIServ :: Typeable a => HscEnv -> IServ -> a -> IO ()
+writeIServ :: (Binary a, Typeable a) => HscEnv -> IServ -> a -> IO ()
 writeIServ hsc_env = lookupHook writeIServHook writeIServ' (hsc_dflags hsc_env) hsc_env
 
-writeIServ' :: Typeable a => HscEnv -> IServ -> a -> IO ()
+writeIServ' :: (Binary a, Typeable a) => HscEnv -> IServ -> a -> IO ()
 writeIServ' _ iserv@IServ {..} a
   | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(Message (QResult ByteString))) =
     writePipe iservPipe (putMessage a)
diff --git a/compiler/main/Hooks.hs b/compiler/main/Hooks.hs
index c967f13e60..a5c50d7f26 100644
--- a/compiler/main/Hooks.hs
+++ b/compiler/main/Hooks.hs
@@ -124,9 +124,9 @@ data Hooks = Hooks
   , cmmToRawCmmHook        :: Maybe (DynFlags -> Maybe Module -> Stream IO CmmGroup ()
             -> IO (Stream IO RawCmmGroup ()))
   , startIServHook         :: Maybe (HscEnv -> IO IServ)
-  , iservCallHook          :: forall a . Binary a => Maybe (HscEnv -> IServ -> Message a -> IO a)
-  , readIServHook          :: forall a . Typeable a => Maybe (HscEnv -> IServ -> IO a)
-  , writeIServHook         :: forall a . Typeable a => Maybe (HscEnv -> IServ -> a -> IO ())
+  , iservCallHook          :: forall a . (Binary a, Typeable a) => Maybe (HscEnv -> IServ -> Message a -> IO a)
+  , readIServHook          :: forall a . (Binary a, Typeable a) => Maybe (HscEnv -> IServ -> IO a)
+  , writeIServHook         :: forall a . (Binary a, Typeable a) => Maybe (HscEnv -> IServ -> a -> IO ())
   , stopIServHook          :: Maybe (HscEnv -> IO ())
   }
 
diff --git a/compiler/typecheck/TcSplice.hs b/compiler/typecheck/TcSplice.hs
index e35fd0bead..7567380d21 100644
--- a/compiler/typecheck/TcSplice.hs
+++ b/compiler/typecheck/TcSplice.hs
@@ -651,7 +651,7 @@ runRemoteModFinalizers (ThModFinalizers finRefs) = do
         Just fhv -> do
           liftIO $ withForeignRef fhv $ \st ->
             withForeignRefs finRefs $ \qrefs ->
-              writeIServ hsc_env i (RunModFinalizers st qrefs)
+              writeIServ hsc_env i $ Msg $ RunModFinalizers st qrefs
           () <- runRemoteTH hsc_env i []
           readQResult hsc_env i
   else do
@@ -1018,7 +1018,7 @@ runTH ty fhv = do
         liftIO $
           withForeignRef rstate $ \state_hv ->
           withForeignRef fhv $ \q_hv ->
-            writeIServ hsc_env i (RunTH state_hv q_hv ty (Just loc))
+            writeIServ hsc_env i $ Msg $ RunTH state_hv q_hv ty (Just loc)
         runRemoteTH hsc_env i []
         bs <- readQResult hsc_env i
         return $! runGet get (LB.fromStrict bs)
diff --git a/libraries/ghci/GHCi/Message.hs b/libraries/ghci/GHCi/Message.hs
index ef03104051..7a3287bc38 100644
--- a/libraries/ghci/GHCi/Message.hs
+++ b/libraries/ghci/GHCi/Message.hs
@@ -308,6 +308,9 @@ putTHMessage m = case m of
   AddForeignFilePath lang a   -> putWord8 20 >> put lang >> put a
   AddCorePlugin a             -> putWord8 21 >> put a
 
+instance Binary THMsg where
+  get = getTHMessage
+  put (THMsg m) = putTHMessage m
 
 data EvalOpts = EvalOpts
   { useSandboxThread :: Bool
@@ -414,7 +417,7 @@ data QState = QState
   }
 instance Show QState where show _ = "<QState>"
 
-data Msg = forall a . (Binary a, Show a) => Msg (Message a)
+data Msg = forall a . (Binary a, Show a, Typeable a) => Msg (Message a)
 
 getMessage :: Get Msg
 getMessage = do
@@ -494,6 +497,10 @@ putMessage m = case m of
   AddSptEntry a b             -> putWord8 33 >> put a >> put b
   RunTH st q loc ty           -> putWord8 34 >> put st >> put q >> put loc >> put ty
 
+instance Binary Msg where
+  get = getMessage
+  put (Msg m) = putMessage m
+
 -- -----------------------------------------------------------------------------
 -- Reading/writing messages
 
-- 
2.23.0


From 15bc2928590c41e445565263a688548746cad5c7 Mon Sep 17 00:00:00 2001
From: Shao Cheng <cheng.shao@tweag.io>
Date: Sun, 15 Sep 2019 04:11:27 +0800
Subject: [PATCH 12/12] asterius iserv

---
 compiler/ghci/GHCi.hs | 69 ++++---------------------------------------
 1 file changed, 5 insertions(+), 64 deletions(-)

diff --git a/compiler/ghci/GHCi.hs b/compiler/ghci/GHCi.hs
index 1942c86dd8..8674f8ea16 100644
--- a/compiler/ghci/GHCi.hs
+++ b/compiler/ghci/GHCi.hs
@@ -465,76 +465,17 @@ readIServ :: forall a. (Binary a, Typeable a) => HscEnv -> IServ -> IO a
 readIServ hsc_env = lookupHook readIServHook readIServ' (hsc_dflags hsc_env) hsc_env
 
 readIServ' :: forall a. (Binary a, Typeable a) => HscEnv -> IServ -> IO a
-readIServ' _ iserv@IServ {..}
-  | Just HRefl <- eqTypeRep (typeRep @a) (typeRep @THMsg) =
-    readPipe iservPipe getTHMessage
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeRep @a) (typeRep @(QResult ByteString)) =
-    readPipe iservPipe get
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeRep @a) (typeRep @(QResult ())) =
-    readPipe iservPipe get
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | otherwise = handleIServFailure iserv $ toException $ userError $ "readIServ: unsupported type " ++ show (typeRep @a)
+readIServ' _ iserv@IServ {..} =
+  readPipe iservPipe get `catch` \(e :: SomeException) ->
+    handleIServFailure iserv e
 
 -- | Send a value to the iserv process
 writeIServ :: (Binary a, Typeable a) => HscEnv -> IServ -> a -> IO ()
 writeIServ hsc_env = lookupHook writeIServHook writeIServ' (hsc_dflags hsc_env) hsc_env
 
 writeIServ' :: (Binary a, Typeable a) => HscEnv -> IServ -> a -> IO ()
-writeIServ' _ iserv@IServ {..} a
-  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(Message (QResult ByteString))) =
-    writePipe iservPipe (putMessage a)
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(Message (QResult ()))) =
-    writePipe iservPipe (putMessage a)
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult TH.Name)) =
-    writePipe iservPipe (put a)
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult ())) =
-    writePipe iservPipe (put a)
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult (Maybe TH.Name))) =
-    writePipe iservPipe (put a)
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult TH.Info)) =
-    writePipe iservPipe (put a)
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult (Maybe TH.Fixity))) =
-    writePipe iservPipe (put a)
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult [TH.Dec])) =
-    writePipe iservPipe (put a)
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult [TH.Role])) =
-    writePipe iservPipe (put a)
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult [ByteString])) =
-    writePipe iservPipe (put a)
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult TH.ModuleInfo)) =
-    writePipe iservPipe (put a)
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult [TH.DecidedStrictness])) =
-    writePipe iservPipe (put a)
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult FilePath)) =
-    writePipe iservPipe (put a)
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult Bool)) =
-    writePipe iservPipe (put a)
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult [Extension])) =
-    writePipe iservPipe (put a)
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @(THResult [Extension])) =
-    writePipe iservPipe (put a)
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | Just HRefl <- eqTypeRep (typeOf a) (typeRep @()) =
-    writePipe iservPipe (put a)
-      `catch` \(e :: SomeException) -> handleIServFailure iserv e
-  | otherwise = handleIServFailure iserv $ toException $ userError $ "writeIServ: unsupported type " ++ show (typeOf a)
+writeIServ' _ iserv@IServ {..} a = writePipe iservPipe (put a)
+  `catch` \(e :: SomeException) -> handleIServFailure iserv e
 
 handleIServFailure :: IServ -> SomeException -> IO a
 handleIServFailure IServ{..} e = do
-- 
2.23.0

