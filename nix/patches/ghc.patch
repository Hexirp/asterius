diff --git a/cmm/CmmInfo.hs b/cmm/CmmInfo.hs
index 43cba2526d..07798d34c7 100644
--- a/cmm/CmmInfo.hs
+++ b/cmm/CmmInfo.hs
@@ -53,6 +53,7 @@ import UniqSupply
 import MonadUtils
 import Util
 import Outputable
+import Module
 
 import Data.Bits
 import Data.Word
@@ -66,9 +67,9 @@ mkEmptyContInfoTable info_lbl
                  , cit_srt  = Nothing
                  , cit_clo  = Nothing }
 
-cmmToRawCmm :: DynFlags -> Stream IO CmmGroup ()
+cmmToRawCmm :: DynFlags -> Maybe Module -> Stream IO CmmGroup ()
             -> IO (Stream IO RawCmmGroup ())
-cmmToRawCmm dflags cmms
+cmmToRawCmm dflags _ cmms
   = do { uniqs <- mkSplitUniqSupply 'i'
        ; let do_one uniqs cmm = do
                 case initUs uniqs $ concatMapM (mkInfoTable dflags) cmm of
diff --git a/deSugar/DsCCall.hs b/deSugar/DsCCall.hs
index 7cab8e8e25..c70e8f0c55 100644
--- a/deSugar/DsCCall.hs
+++ b/deSugar/DsCCall.hs
@@ -7,13 +7,7 @@ Desugaring foreign calls
 -}
 
 {-# LANGUAGE CPP #-}
-module DsCCall
-        ( dsCCall
-        , mkFCall
-        , unboxArg
-        , boxResult
-        , resultWrapper
-        ) where
+module DsCCall where
 
 #include "HsVersions.h"
 
diff --git a/deSugar/DsForeign.hs b/deSugar/DsForeign.hs
index d34c3a791a..cebc8d78c7 100644
--- a/deSugar/DsForeign.hs
+++ b/deSugar/DsForeign.hs
@@ -11,7 +11,7 @@ Desugaring foreign declarations (see also DsCCall).
 {-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE ViewPatterns #-}
 
-module DsForeign ( dsForeigns ) where
+module DsForeign where
 
 #include "HsVersions.h"
 import GhcPrelude
diff --git a/ghci/ByteCodeItbls.hs b/ghci/ByteCodeItbls.hs
index 7381c8f926..c17f213365 100644
--- a/ghci/ByteCodeItbls.hs
+++ b/ghci/ByteCodeItbls.hs
@@ -71,6 +71,8 @@ make_constr_itbls hsc_env cons =
 
          descr = dataConIdentity dcon
 
-     r <- iservCmd hsc_env (MkConInfoTable ptrs' nptrs_really
+         tables_next_to_code = tablesNextToCode dflags
+
+     r <- iservCmd hsc_env (MkConInfoTable tables_next_to_code ptrs' nptrs_really
                               conNo (tagForCon dflags dcon) descr)
      return (getName dcon, ItblPtr r)
diff --git a/ghci/GHCi.hs b/ghci/GHCi.hs
index 579053999f..d97fb34c4e 100644
--- a/ghci/GHCi.hs
+++ b/ghci/GHCi.hs
@@ -1,4 +1,6 @@
 {-# LANGUAGE RecordWildCards, ScopedTypeVariables, BangPatterns, CPP #-}
+{-# LANGUAGE GADTs #-}
+{-# LANGUAGE TypeApplications #-}
 
 --
 -- | Interacting with the interpreter, whether it is running on an
@@ -40,6 +42,7 @@ module GHCi
   -- * Lower-level API using messages
   , iservCmd, Message(..), withIServ, stopIServ
   , iservCall, readIServ, writeIServ
+  , iservCall', readIServ', writeIServ'
   , purgeLookupSymbolCache
   , freeHValueRefs
   , mkFinalizedHValue
@@ -93,6 +96,9 @@ import System.Posix as Posix
 import System.Directory
 import System.Process
 import GHC.Conc (getNumProcessors, pseq, par)
+import qualified Language.Haskell.TH.Syntax as TH
+import GHC.LanguageExtensions.Type
+import Type.Reflection
 
 {- Note [Remote GHCi]
 
@@ -168,12 +174,12 @@ needExtInt = throwIO
 -- external iserv process, and the response is deserialized (hence the
 -- @Binary@ constraint).  With @-fno-external-interpreter@ we execute
 -- the command directly here.
-iservCmd :: Binary a => HscEnv -> Message a -> IO a
+iservCmd :: (Binary a, Typeable a) => HscEnv -> Message a -> IO a
 iservCmd hsc_env@HscEnv{..} msg
  | gopt Opt_ExternalInterpreter hsc_dflags =
      withIServ hsc_env $ \iserv ->
        uninterruptibleMask_ $ do -- Note [uninterruptibleMask_]
-         iservCall iserv msg
+         iservCall hsc_env iserv msg
  | otherwise = -- Just run it directly
 #if defined(GHCI)
    run msg
@@ -195,17 +201,17 @@ iservCmd hsc_env@HscEnv{..} msg
 withIServ
   :: (MonadIO m, ExceptionMonad m)
   => HscEnv -> (IServ -> m a) -> m a
-withIServ HscEnv{..} action =
+withIServ hsc_env@HscEnv{..} action =
   gmask $ \restore -> do
     m <- liftIO $ takeMVar hsc_iserv
       -- start the iserv process if we haven't done so yet
-    iserv <- maybe (liftIO $ startIServ hsc_dflags) return m
+    iserv <- maybe (liftIO $ startIServ hsc_env) return m
                `gonException` (liftIO $ putMVar hsc_iserv Nothing)
       -- free any ForeignHValues that have been garbage collected.
     let iserv' = iserv{ iservPendingFrees = [] }
     a <- (do
       liftIO $ when (not (null (iservPendingFrees iserv))) $
-        iservCall iserv (FreeHValueRefs (iservPendingFrees iserv))
+        iservCall hsc_env iserv (FreeHValueRefs (iservPendingFrees iserv))
         -- run the inner action
       restore $ action iserv)
           `gonException` (liftIO $ putMVar hsc_iserv (Just iserv'))
@@ -383,7 +389,7 @@ lookupSymbol hsc_env@HscEnv{..} str
          Just p -> return (Just p)
          Nothing -> do
            m <- uninterruptibleMask_ $
-                    iservCall iserv (LookupSymbol (unpackFS str))
+                    iservCall hsc_env iserv (LookupSymbol (unpackFS str))
            case m of
              Nothing -> return Nothing
              Just r -> do
@@ -460,22 +466,30 @@ findSystemLibrary hsc_env str = iservCmd hsc_env (FindSystemLibrary str)
 -- Raw calls and messages
 
 -- | Send a 'Message' and receive the response from the iserv process
-iservCall :: Binary a => IServ -> Message a -> IO a
-iservCall iserv@IServ{..} msg =
+iservCall :: (Binary a, Typeable a) => HscEnv -> IServ -> Message a -> IO a
+iservCall hsc_env = lookupHook iservCallHook iservCall' (hsc_dflags hsc_env) hsc_env
+
+iservCall' :: (Binary a, Typeable a) => HscEnv -> IServ -> Message a -> IO a
+iservCall' _ iserv@IServ{..} msg =
   remoteCall iservPipe msg
     `catch` \(e :: SomeException) -> handleIServFailure iserv e
 
 -- | Read a value from the iserv process
-readIServ :: IServ -> Get a -> IO a
-readIServ iserv@IServ{..} get =
-  readPipe iservPipe get
-    `catch` \(e :: SomeException) -> handleIServFailure iserv e
+readIServ :: forall a. (Binary a, Typeable a) => HscEnv -> IServ -> IO a
+readIServ hsc_env = lookupHook readIServHook readIServ' (hsc_dflags hsc_env) hsc_env
+
+readIServ' :: forall a. (Binary a, Typeable a) => HscEnv -> IServ -> IO a
+readIServ' _ iserv@IServ {..} =
+  readPipe iservPipe get `catch` \(e :: SomeException) ->
+    handleIServFailure iserv e
 
 -- | Send a value to the iserv process
-writeIServ :: IServ -> Put -> IO ()
-writeIServ iserv@IServ{..} put =
-  writePipe iservPipe put
-    `catch` \(e :: SomeException) -> handleIServFailure iserv e
+writeIServ :: (Binary a, Typeable a) => HscEnv -> IServ -> a -> IO ()
+writeIServ hsc_env = lookupHook writeIServHook writeIServ' (hsc_dflags hsc_env) hsc_env
+
+writeIServ' :: (Binary a, Typeable a) => HscEnv -> IServ -> a -> IO ()
+writeIServ' _ iserv@IServ {..} a = writePipe iservPipe (put a)
+  `catch` \(e :: SomeException) -> handleIServFailure iserv e
 
 handleIServFailure :: IServ -> SomeException -> IO a
 handleIServFailure IServ{..} e = do
@@ -491,9 +505,14 @@ handleIServFailure IServ{..} e = do
 -- -----------------------------------------------------------------------------
 -- Starting and stopping the iserv process
 
-startIServ :: DynFlags -> IO IServ
-startIServ dflags = do
-  let flavour
+startIServ :: HscEnv -> IO IServ
+startIServ hsc_env =
+  maybe (startIServ' hsc_env) ($ hsc_env) (startIServHook (hooks (hsc_dflags hsc_env)))
+
+startIServ' :: HscEnv -> IO IServ
+startIServ' hsc_env = do
+  let dflags = hsc_dflags hsc_env
+      flavour
         | WayProf `elem` ways dflags = "-prof"
         | WayDyn `elem` ways dflags = "-dyn"
         | otherwise = ""
@@ -517,7 +536,11 @@ startIServ dflags = do
     }
 
 stopIServ :: HscEnv -> IO ()
-stopIServ HscEnv{..} =
+stopIServ hsc_env@HscEnv {..} =
+  maybe (stopIServ' hsc_env) ($ hsc_env) (stopIServHook (hooks hsc_dflags))
+
+stopIServ' :: HscEnv -> IO ()
+stopIServ' hsc_env@HscEnv{..} =
   gmask $ \_restore -> do
     m <- takeMVar hsc_iserv
     maybe (return ()) stop m
@@ -527,7 +550,7 @@ stopIServ HscEnv{..} =
     ex <- getProcessExitCode (iservProcess iserv)
     if isJust ex
        then return ()
-       else iservCall iserv Shutdown
+       else iservCall hsc_env iserv Shutdown
 
 runWithPipes :: (CreateProcess -> IO ProcessHandle)
              -> FilePath -> [String] -> IO (ProcessHandle, Handle, Handle)
diff --git a/ghci/Linker.hs b/ghci/Linker.hs
index 41cc218e12..6ea3ae2261 100644
--- a/ghci/Linker.hs
+++ b/ghci/Linker.hs
@@ -17,6 +17,7 @@ module Linker ( getHValue, showLinkerState,
                 extendLoadedPkgs,
                 linkPackages,initDynLinker,linkModule,
                 linkCmdLineLibs
+                ,modifyPLS,linkDependencies
         ) where
 
 #include "HsVersions.h"
diff --git a/main/DynFlags.hs b/main/DynFlags.hs
index a7ec70f876..9c4ac137e8 100644
--- a/main/DynFlags.hs
+++ b/main/DynFlags.hs
@@ -58,7 +58,7 @@ module DynFlags (
         fFlags, fLangFlags, xFlags,
         wWarningFlags,
         dynFlagDependencies,
-        tablesNextToCode, mkTablesNextToCode,
+        mkTablesNextToCode,
         makeDynFlagsConsistent,
         shouldUseColor,
         shouldUseHexWordLiterals,
@@ -873,6 +873,7 @@ data DynFlags = DynFlags {
   integerLibrary        :: IntegerLibrary,
     -- ^ IntegerGMP or IntegerSimple. Set at configure time, but may be overriden
     --   by GHC-API users. See Note [The integer library] in PrelNames
+  tablesNextToCode      :: Bool,
   llvmTargets           :: LlvmTargets,
   llvmPasses            :: LlvmPasses,
   verbosity             :: Int,         -- ^ Verbosity level: see Note [Verbosity levels]
@@ -1611,10 +1612,6 @@ defaultObjectTarget platform
   | cGhcWithNativeCodeGen == "YES"      =  HscAsm
   | otherwise                           =  HscLlvm
 
-tablesNextToCode :: DynFlags -> Bool
-tablesNextToCode dflags
-    = mkTablesNextToCode (platformUnregisterised (targetPlatform dflags))
-
 -- Determines whether we will be compiling
 -- info tables that reside just before the entry code, or with an
 -- indirection to the entry code.  See TABLES_NEXT_TO_CODE in
@@ -1874,6 +1871,7 @@ defaultDynFlags mySettings (myLlvmTargets, myLlvmPasses) =
         ghcLink                 = LinkBinary,
         hscTarget               = defaultHscTarget (sTargetPlatform mySettings),
         integerLibrary          = cIntegerLibraryType,
+        tablesNextToCode        = mkTablesNextToCode (platformUnregisterised (sTargetPlatform mySettings)),
         verbosity               = 0,
         optLevel                = 0,
         debugLevel              = 0,
diff --git a/main/Hooks.hs b/main/Hooks.hs
index f9d420ab61..9db7b8b1a2 100644
--- a/main/Hooks.hs
+++ b/main/Hooks.hs
@@ -4,6 +4,7 @@
 --     refer to *types*, rather than *code*
 
 {-# LANGUAGE CPP #-}
+{-# LANGUAGE RankNTypes #-}
 module Hooks ( Hooks
              , emptyHooks
              , lookupHook
@@ -21,6 +22,13 @@ module Hooks ( Hooks
              , runRnSpliceHook
              , getValueSafelyHook
              , createIservProcessHook
+             , stgCmmHook
+             , cmmToRawCmmHook
+             , startIServHook
+             , iservCallHook
+             , readIServHook
+             , writeIServHook
+             , stopIServHook
              ) where
 
 import GhcPrelude
@@ -44,8 +52,17 @@ import Type
 import System.Process
 import BasicTypes
 import HsExtension
+import Module
+import TyCon
+import CostCentre
+import StgSyn
+import Stream
+import Cmm
+import GHCi.Message
 
+import Data.Binary
 import Data.Maybe
+import Type.Reflection (Typeable)
 
 {-
 ************************************************************************
@@ -73,6 +90,13 @@ emptyHooks = Hooks
   , runRnSpliceHook        = Nothing
   , getValueSafelyHook     = Nothing
   , createIservProcessHook = Nothing
+  , stgCmmHook             = Nothing
+  , cmmToRawCmmHook        = Nothing
+  , startIServHook         = Nothing
+  , iservCallHook          = Nothing
+  , readIServHook          = Nothing
+  , writeIServHook         = Nothing
+  , stopIServHook          = Nothing
   }
 
 data Hooks = Hooks
@@ -95,6 +119,15 @@ data Hooks = Hooks
   , getValueSafelyHook     :: Maybe (HscEnv -> Name -> Type
                                                           -> IO (Maybe HValue))
   , createIservProcessHook :: Maybe (CreateProcess -> IO ProcessHandle)
+  , stgCmmHook             :: Maybe (DynFlags -> Module -> [TyCon] -> CollectedCCs
+            -> [CgStgTopBinding] -> HpcInfo -> Stream IO CmmGroup ())
+  , cmmToRawCmmHook        :: Maybe (DynFlags -> Maybe Module -> Stream IO CmmGroup ()
+            -> IO (Stream IO RawCmmGroup ()))
+  , startIServHook         :: Maybe (HscEnv -> IO IServ)
+  , iservCallHook          :: forall a . (Binary a, Typeable a) => Maybe (HscEnv -> IServ -> Message a -> IO a)
+  , readIServHook          :: forall a . (Binary a, Typeable a) => Maybe (HscEnv -> IServ -> IO a)
+  , writeIServHook         :: forall a . (Binary a, Typeable a) => Maybe (HscEnv -> IServ -> a -> IO ())
+  , stopIServHook          :: Maybe (HscEnv -> IO ())
   }
 
 getHooked :: (Functor f, HasDynFlags f) => (Hooks -> Maybe a) -> a -> f a
diff --git a/main/HscMain.hs b/main/HscMain.hs
index 879e6c75ac..a8a02f8987 100644
--- a/main/HscMain.hs
+++ b/main/HscMain.hs
@@ -80,6 +80,7 @@ module HscMain
     , ioMsgMaybe
     , showModuleIndex
     , hscAddSptEntries
+    , doCodeGen
     ) where
 
 import GhcPrelude
@@ -1378,7 +1379,7 @@ hscGenHardCode hsc_env cgguts mod_summary output_filename = do
 
             ------------------  Code output -----------------------
             rawcmms0 <- {-# SCC "cmmToRawCmm" #-}
-                      cmmToRawCmm dflags cmms
+                      lookupHook cmmToRawCmmHook cmmToRawCmm dflags dflags (Just this_mod) cmms
 
             let dump a = do dumpIfSet_dyn dflags Opt_D_dump_cmm_raw "Raw Cmm"
                               (ppr a)
@@ -1437,8 +1438,7 @@ hscCompileCmmFile hsc_env filename output_filename = runHsc hsc_env $ do
             mod_name = mkModuleName $ "Cmm$" ++ FilePath.takeFileName filename
             cmm_mod = mkModule (thisPackage dflags) mod_name
         (_, cmmgroup) <- cmmPipeline hsc_env (emptySRT cmm_mod) cmm
-        dumpIfSet_dyn dflags Opt_D_dump_cmm "Output Cmm" (ppr cmmgroup)
-        rawCmms <- cmmToRawCmm dflags (Stream.yield cmmgroup)
+        rawCmms <- lookupHook cmmToRawCmmHook cmmToRawCmm dflags dflags Nothing (Stream.yield cmmgroup)
         _ <- codeOutput dflags cmm_mod output_filename no_loc NoStubs [] []
              rawCmms
         return ()
@@ -1465,7 +1465,7 @@ doCodeGen hsc_env this_mod data_tycons
     let stg_binds_w_fvs = annTopBindingsFreeVars stg_binds
     let cmm_stream :: Stream IO CmmGroup ()
         cmm_stream = {-# SCC "StgCmm" #-}
-            StgCmm.codeGen dflags this_mod data_tycons
+            lookupHook stgCmmHook StgCmm.codeGen dflags dflags this_mod data_tycons
                            cost_centre_info stg_binds_w_fvs hpc_info
 
         -- codegen consumes a stream of CmmGroup, and produces a new
diff --git a/main/SysTools.hs b/main/SysTools.hs
index 9bbce19602..dd15008d1a 100644
--- a/main/SysTools.hs
+++ b/main/SysTools.hs
@@ -199,15 +199,9 @@ initSysTools top_dir
        let unreg_gcc_args = if targetUnregisterised
                             then ["-DNO_REGS", "-DUSE_MINIINTERPRETER"]
                             else []
-           -- TABLES_NEXT_TO_CODE affects the info table layout.
-           tntc_gcc_args
-            | mkTablesNextToCode targetUnregisterised
-               = ["-DTABLES_NEXT_TO_CODE"]
-            | otherwise = []
            cpp_args= map Option (words cpp_args_str)
            gcc_args = map Option (words gcc_args_str
-                               ++ unreg_gcc_args
-                               ++ tntc_gcc_args)
+                               ++ unreg_gcc_args)
        ldSupportsCompactUnwind <- getBooleanSetting "ld supports compact unwind"
        ldSupportsBuildId       <- getBooleanSetting "ld supports build-id"
        ldSupportsFilelist      <- getBooleanSetting "ld supports filelist"
diff --git a/typecheck/TcForeign.hs b/typecheck/TcForeign.hs
index 8038de3d84..b6fd66c720 100644
--- a/typecheck/TcForeign.hs
+++ b/typecheck/TcForeign.hs
@@ -15,21 +15,7 @@ module checks to see if a foreign declaration has got a legal type.
 {-# LANGUAGE CPP #-}
 {-# LANGUAGE TypeFamilies #-}
 
-module TcForeign
-        ( tcForeignImports
-        , tcForeignExports
-
-        -- Low-level exports for hooks
-        , isForeignImport, isForeignExport
-        , tcFImport, tcFExport
-        , tcForeignImports'
-        , tcCheckFIType, checkCTarget, checkForeignArgs, checkForeignRes
-        , normaliseFfiType
-        , nonIOok, mustBeIO
-        , checkSafe, noCheckSafe
-        , tcForeignExports'
-        , tcCheckFEType
-        ) where
+module TcForeign where
 
 #include "HsVersions.h"
 
diff --git a/typecheck/TcRnDriver.hs b/typecheck/TcRnDriver.hs
index 6e9c8977f9..57237cc932 100644
--- a/typecheck/TcRnDriver.hs
+++ b/typecheck/TcRnDriver.hs
@@ -90,7 +90,7 @@ import HeaderInfo       ( mkPrelImports )
 import TcDefaults
 import TcEnv
 import TcRules
-import TcForeign
+import TcForeign hiding (check)
 import TcInstDcls
 import TcIface
 import TcMType
diff --git a/typecheck/TcSplice.hs b/typecheck/TcSplice.hs
index 2c76e6cbe0..e23841bacd 100644
--- a/typecheck/TcSplice.hs
+++ b/typecheck/TcSplice.hs
@@ -673,9 +673,9 @@ runRemoteModFinalizers (ThModFinalizers finRefs) = do
         Just fhv -> do
           liftIO $ withForeignRef fhv $ \st ->
             withForeignRefs finRefs $ \qrefs ->
-              writeIServ i (putMessage (RunModFinalizers st qrefs))
-          () <- runRemoteTH i []
-          readQResult i
+              writeIServ hsc_env i $ Msg $ RunModFinalizers st qrefs
+          () <- runRemoteTH hsc_env i []
+          readQResult hsc_env i
   else do
     qs <- liftIO (withForeignRefs finRefs $ mapM localRef)
     runQuasi $ sequence_ qs
@@ -1094,27 +1094,28 @@ runTH ty fhv = do
         liftIO $
           withForeignRef rstate $ \state_hv ->
           withForeignRef fhv $ \q_hv ->
-            writeIServ i (putMessage (RunTH state_hv q_hv ty (Just loc)))
-        runRemoteTH i []
-        bs <- readQResult i
+            writeIServ hsc_env i $ Msg $ RunTH state_hv q_hv ty (Just loc)
+        runRemoteTH hsc_env i []
+        bs <- readQResult hsc_env i
         return $! runGet get (LB.fromStrict bs)
 
 
 -- | communicate with a remotely-running TH computation until it finishes.
 -- See Note [Remote Template Haskell] in libraries/ghci/GHCi/TH.hs.
 runRemoteTH
-  :: IServ
+  :: HscEnv
+  -> IServ
   -> [Messages]   --  saved from nested calls to qRecover
   -> TcM ()
-runRemoteTH iserv recovers = do
-  THMsg msg <- liftIO $ readIServ iserv getTHMessage
+runRemoteTH hsc_env iserv recovers = do
+  THMsg msg <- liftIO $ readIServ hsc_env iserv
   case msg of
     RunTHDone -> return ()
     StartRecover -> do -- Note [TH recover with -fexternal-interpreter]
       v <- getErrsVar
       msgs <- readTcRef v
       writeTcRef v emptyMessages
-      runRemoteTH iserv (msgs : recovers)
+      runRemoteTH hsc_env iserv (msgs : recovers)
     EndRecover caught_error -> do
       let (prev_msgs@(prev_warns,prev_errs), rest) = case recovers of
              [] -> panic "EndRecover"
@@ -1125,16 +1126,16 @@ runRemoteTH iserv recovers = do
       writeTcRef v $ if caught_error
         then prev_msgs
         else (prev_warns `unionBags` warn_msgs, prev_errs)
-      runRemoteTH iserv rest
+      runRemoteTH hsc_env iserv rest
     _other -> do
       r <- handleTHMessage msg
-      liftIO $ writeIServ iserv (put r)
-      runRemoteTH iserv recovers
+      liftIO $ writeIServ hsc_env iserv r
+      runRemoteTH hsc_env iserv recovers
 
 -- | Read a value of type QResult from the iserv
-readQResult :: Binary a => IServ -> TcM a
-readQResult i = do
-  qr <- liftIO $ readIServ i get
+readQResult :: (Binary a, Typeable a) => HscEnv -> IServ -> TcM a
+readQResult hsc_env i = do
+  qr <- liftIO $ readIServ hsc_env i
   case qr of
     QDone a -> return a
     QException str -> liftIO $ throwIO (ErrorCall str)
@@ -1189,7 +1190,7 @@ getTHState i = do
     Just rhv -> return rhv
     Nothing -> do
       hsc_env <- env_top <$> getEnv
-      fhv <- liftIO $ mkFinalizedHValue hsc_env =<< iservCall i StartTH
+      fhv <- liftIO $ mkFinalizedHValue hsc_env =<< iservCall hsc_env i StartTH
       writeTcRef (tcg_th_remote_state tcg) (Just fhv)
       return fhv
 
diff --git a/utils/Util.hs b/utils/Util.hs
index 46ef0e6ab9..c6a3bd19b1 100644
--- a/utils/Util.hs
+++ b/utils/Util.hs
@@ -11,7 +11,6 @@
 module Util (
         -- * Flags dependent on the compiler build
         ghciSupported, debugIsOn, ncgDebugIsOn,
-        ghciTablesNextToCode,
         isWindowsHost, isDarwinHost,
 
         -- * General list processing
@@ -206,13 +205,6 @@ ncgDebugIsOn = True
 ncgDebugIsOn = False
 #endif
 
-ghciTablesNextToCode :: Bool
-#if defined(GHCI_TABLES_NEXT_TO_CODE)
-ghciTablesNextToCode = True
-#else
-ghciTablesNextToCode = False
-#endif
-
 isWindowsHost :: Bool
 #if defined(mingw32_HOST_OS)
 isWindowsHost = True
